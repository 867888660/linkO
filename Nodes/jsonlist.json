[
    {
        "Filename": "Add.py",
        "Hash": "b674dbca8e7bfc6fa675e78f8e1e840c7e26a7d1bf2ecdf24fd6eec2bcccd457",
        "NodeKind": "Normal",
        "NodeFunction": "Unknown"
    },
    {
        "Filename": "addCharacterexcel.py",
        "Hash": "8f9bdc37d8b4a5a0a75a02def7c99cb2e3df355acb58c32119cde21e169cb616",
        "NodeKind": "Normal",
        "NodeFunction": "可以通过它将json添加为Excel表格\\nFilename:用于填写Excel表格的文件名\\nFilePath:用于填写Excel表格的文件路径\\nContent:用于填写Excel表格的内容，格式为JSON字符串"
    },
    {
        "Filename": "addexcelevent.py",
        "Hash": "0d6b8c4581fb8ca72fa4f99eeee35e1c9fd0ce79e5f9bd47d27262cdcad1dfae",
        "NodeKind": "Normal",
        "NodeFunction": "Unknown"
    },
    {
        "Filename": "AddIntroduce.py",
        "Hash": "51e54e0389dd715121452774b99d55ee3fea1531cbf14ebc391e75b6f0dab91c",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能\\\\n将给定的介绍文本更新到指定Python文件的FunctionIntroduction变量中，支持单行和多行文本的安全处理。\\\\n\\\\n代码功能摘要\\\\n通过文件IO和正则表达式，定位并替换Python文件中的FunctionIntroduction变量赋值。对输入文本进行预处理和转义，确保多行文本的正确存储。支持处理单行赋值和多行区块赋值两种情况。\\\\n\\\\ninputs:\\\\n  - name: File_Path\\\\n    type: string\\\\n    required: true\\\\n    description: 需要修改的Python文件的完整路径\\\\n  - name: Introduce\\\\n    type: string\\\\n    required: true\\\\n    description: 新的介绍文本内容\\\\n\\\\noutputs:\\\\n  - name: Result\\\\n    type: string\\\\n    description: 操作执行结果和详细调试信息\\\\n\\\\n运行逻辑\\\\n- 验证输入的文件路径是否存在且有效\\\\n- 对输入的介绍文本进行预处理：\\\\n  - 统一各种换行符为\\\\\\\\n\\\\n  - 使用json.dumps进行安全转义\\\\n  - 处理单引号的转义\\\\n- 读取目标Python文件的所有内容\\\\n- 使用正则表达式查找FunctionIntroduction变量的赋值位置\\\\n- 如果找到现有赋值：\\\\n  - 判断是否为多行区块赋值(带括号)\\\\n  - 删除旧的赋值内容（可能跨多行）\\\\n  - 在原位置插入新的赋值语句\\\\n- 如果未找到现有赋值：\\\\n  - 在第10行位置插入新的赋值语句\\\\n- 将修改后的内容写回原文件\\\\n- 返回包含执行状态和调试信息的结果字符串"
    },
    {
        "Filename": "addtxt.py",
        "Hash": "0dc4feb0400e79d68aa78db763b3cfa39fb833ef77e581f8fb4a3e42fe55bb91",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能  \\n这是一个文件内容追加程序，能够向指定的文本文件追加内容。如果文件路径中的目录不存在，会自动创建；若文件本身不存在，则会自动创建空文件并进行内容追加。\\n\\n代码功能摘要  \\n该程序的核心功能包括：检查和创建目标文件路径的目录，检查并创建目标文件（如果文件不存在），然后将指定的文本内容追加到文件末尾。内容追加时会使用 UTF-8 编码，确保文件支持中文等字符。\\n\\n参数  \\n```yaml\\ninputs:\\n  - name: File_Path\\n    type: string\\n    required: true\\n    description: 需要追加内容的文件路径\\n    frozen: true\\n  - name: Content\\n    type: string\\n    required: true\\n    description: 需要追加到文件中的文本内容\\n    frozen: false\\noutputs:\\n  - name: Result\\n    type: string\\n    description: 返回操作结果的提示信息\\n```\\n\\n运行逻辑  \\n- 检查输入的文件路径中的目录是否存在：\\n  - 如果目录不存在，创建所需的目录结构。如果目录创建失败，记录错误日志并抛出异常。\\n- 检查目标文件是否存在：\\n  - 如果文件不存在，创建一个空文件。如果文件创建失败，记录错误日志并抛出异常。\\n- 使用 UTF-8 编码打开文件，并追加内容：\\n  - 在要追加的内容前后添加换行符，确保格式整洁。\\n  - 将内容追加到文件末尾。如果写入失败，记录错误日志并抛出异常。\\n- 返回操作结果提示信息：\\\"Content added to {filepath}\\\""
    },
    {
        "Filename": "Add_Node.py",
        "Hash": "582bd496b2740c702827d0efd730305193d4d5c114ac2641090afbead4645524",
        "NodeKind": "Normal",
        "NodeFunction": "**组件功能：**  \\n该代码实现了一个节点插入器的功能，能够向一个工作流JSON文件中插入新的节点，并确保节点ID和标签的唯一性。插入的过程包括检查重复的节点ID和标签，确保每个节点的唯一性，最终将更新后的数据保存回文件。\\n\\n**代码功能摘要：**  \\n1. 该代码首先验证输入的文件路径和JSON字符串的有效性。\\n2. 它读取并解析目标工作流文件，解析输入的节点JSON。\\n3. 新的节点会被添加到工作流的`nodes`数组中，接着对所有节点进行去重处理（包括`id`和`label`）。\\n4. 去重完成后，更新的工作流会保存回文件。\\n5. 最后，生成操作结果和调试信息作为输出。\\n\\n**参数：**  \\n```yaml\\ninputs:\\n  - name: File_Path\\n    type: string\\n    required: true\\n    description: 目标工作流JSON文件的路径\\n    frozen: true\\n  - name: Json\\n    type: string\\n    required: true\\n    description: 要插入的节点的JSON字符串\\n    frozen: true\\noutputs:\\n  - name: Result\\n    type: string\\n    description: 操作结果信息\\n  - name: Debug\\n    type: string\\n    description: 详细的调试信息输出\\n```\\n\\n**运行逻辑：**  \\n- 读取输入：  \\n  - 验证文件路径和JSON字符串的有效性。\\n  - 如果文件路径无效或JSON字符串为空，抛出相应错误。\\n  \\n- 数据处理：  \\n  - 读取目标工作流文件，检查文件中是否包含`nodes`数组。\\n  - 解析输入的节点JSON，支持代码块格式的解析。\\n  - 将新的节点数据添加到现有的`nodes`数组。\\n\\n- 节点去重处理：  \\n  - 遍历所有节点，确保每个节点的`id`和`label`在全局范围内唯一。\\n  - 如有重复，依次在末尾加上`*`，直到节点不再重复。\\n  - 记录所有重命名的操作并输出调试信息。\\n\\n- 文件保存：  \\n  - 将更新后的工作流数据写回到原文件中，采用UTF-8编码并格式化为缩进的JSON格式。\\n\\n- 生成输出：  \\n  - 返回操作结果信息，成功时显示“OK: 现有节点总数 X”，失败时显示相应的错误信息。\\n  - 输出完整的调试信息记录，帮助用户了解处理过程。"
    },
    {
        "Filename": "AliOcr.py",
        "Hash": "3cb9cb41faf4b25ca973bc4d97533b5fb8c6f2f936662eed248d7c1e87df7aa6",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个使用阿里云OCR API进行手写体识别的程序，能够读取图片文件并识别其中的手写文字内容。\\\\n\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n程序首先验证输入文件的存在性和格式有效性，然后使用阿里云OCR API客户端读取图片二进制数据，配置手写体识别参数（包括自动旋转、段落识别等），发送识别请求并处理返回结果，最终输出识别到的文字内容或相应的错误信息。\\\\n\\\\n参数\\\\n```yaml\\\\ninputs:\\\\n  - name: File_Path\\\\n    type: file\\\\n    required: true\\\\n    description: 需要进行OCR识别的图片文件路径\\\\noutputs:\\\\n  - name: Result\\\\n    type: string\\\\n    description: 识别结果文本或错误信息\\\\n```\\\\n\\\\n运行逻辑（用 - 列表描写详细流程）\\\\n- 接收输入的图片文件路径参数\\\\n- 验证文件是否存在，如不存在则返回文件未找到错误\\\\n- 检查文件扩展名是否为支持的图片格式（.png、.jpg、.jpeg、.bmp、.gif、.tiff、.webp），如不支持则返回格式错误信息\\\\n- 导入阿里云OCR相关模块和客户端类\\\\n- 使用硬编码的访问密钥创建OCR客户端配置，设置服务端点为杭州区域\\\\n- 以二进制模式读取图片文件内容\\\\n- 创建手写体识别请求对象，配置参数：关闭字符信息输出、开启图片自动旋转、关闭表格输出、关闭页面排序、开启段落识别\\\\n- 设置运行时选项并发送OCR识别请求\\\\n- 处理API响应结果：如果成功则提取识别的文字数据，如果失败则构造包含错误代码和消息的错误信息\\\\n- 使用logging记录完整的OCR响应信息用于调试\\\\n- 捕获并处理可能出现的异常，记录错误日志\\\\n- 将最终结果（识别文字或错误信息）赋值给输出参数并返回"
    },
    {
        "Filename": "Array_Model.py",
        "Hash": "cc2c606123004889d27caa14042d1fe852fbde6e26e03a28245ca9f6d6b752d3",
        "NodeKind": "ArrayTrigger",
        "NodeFunction": "组件功能：这是一个数组触发器节点，用于根据指定的数字范围生成包含输出节点序列的数组。\\n\\n代码功能摘要：接收起始和结束数字作为输入，通过循环遍历指定范围内的每个数字，为每个数字创建一个输出节点的深拷贝并存储到数组中，最终返回包含所有数字序列的数组。\\n\\n参数：\\\\n```yaml\\\\ninputs:\\\\n  - name: Input1\\\\n    type: integer\\\\n    required: true\\\\n    description: 数字范围的起始值\\\\n  - name: Input2\\\\n    type: integer\\\\n    required: true\\\\n    description: 数字范围的结束值（包含）\\\\noutputs:\\\\n  - name: OutPut1\\\\n    type: string\\\\n    description: 生成的数组序列，包含指定范围内所有数字对应的输出节点\\\\n```\\n\\n运行逻辑：\\\\n- 从输入节点获取起始数字Start_Num和结束数字End_Num\\\\n- 初始化空数组Array用于存储结果\\\\n- 使用for循环遍历从Start_Num到End_Num+1的范围（包含结束值）\\\\n- 在每次循环中，将当前数字i赋值给输出节点的Num属性\\\\n- 对当前输出节点进行深拷贝并添加到Array数组中\\\\n- 循环结束后返回包含所有数字序列的Array数组\\\\n- 每个数组元素都是一个完整的输出节点对象，包含对应的数字值"
    },
    {
        "Filename": "Azure.py",
        "Hash": "f22a72524b77afa213abfb795b7ae5312697045182f5113bb1d0ffb32d8f8a7c",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能：这是一个Azure文本转语音(TTS)转换节点，用于将文本内容转换为语音文件并保存到指定路径。\\\\n\\\\n代码功能摘要：通过Azure语音服务API，使用SSML格式构建请求体，支持自定义语音角色、情感和语速参数，将文本转换为MP3音频文件，同时保存音频描述文件。\\\\n\\\\n参数：\\\\n```yaml\\\\ninputs:\\\\n  - name: Authorization\\\\n    type: string\\\\n    required: true\\\\n    description: Azure语音服务认证密钥\\\\n  - name: Prompt\\\\n    type: string\\\\n    required: true\\\\n    description: 需要转换为语音的文本内容\\\\n  - name: Voice\\\\n    type: string\\\\n    required: true\\\\n    description: 语音角色名称\\\\n  - name: Url\\\\n    type: string\\\\n    required: true\\\\n    description: Azure语音服务API地址\\\\n  - name: save_path\\\\n    type: file\\\\n    required: true\\\\n    description: 音频文件保存路径\\\\n  - name: audio_name\\\\n    type: string\\\\n    required: true\\\\n    description: 音频文件名称（不含扩展名）\\\\n  - name: audio_descript\\\\n    type: string\\\\n    required: true\\\\n    description: 音频描述内容\\\\n  - name: Emotion\\\\n    type: string\\\\n    required: false\\\\n    description: 语音情感风格（可选）\\\\n  - name: Speed\\\\n    type: string\\\\n    required: false\\\\n    description: 语音速度（可选，默认1.0）\\\\n    default: \\\\\\\"1.0\\\\\\\"\\\\noutputs:\\\\n  - name: result\\\\n    type: string\\\\n    description: 转换结果，成功返回Success，失败返回错误信息\\\\n```\\\\n\\\\n运行逻辑：\\\\n- 获取所有输入参数，包括认证密钥、文本内容、语音角色等\\\\n- 对URL进行格式化处理，确保以/cognitiveservices/v1结尾\\\\n- 清理和处理语音角色、情感和速度参数\\\\n- 根据是否有情感参数构建不同的语音标签\\\\n- 使用SSML格式构建请求体，包含voice标签和prosody标签控制语速\\\\n- 设置HTTP请求头，包含认证密钥和输出格式\\\\n- 发送POST请求到Azure语音服务API\\\\n- 检查响应状态码，如果成功（200）则继续处理\\\\n- 确保保存目录存在，不存在则创建\\\\n- 将响应的音频内容保存为MP3文件\\\\n- 创建同名的txt文件保存音频描述信息\\\\n- 返回处理结果，成功返回Success，失败返回具体错误信息\\\\n- 整个过程包含完整的异常处理和调试日志输出"
    },
    {
        "Filename": "chatts.py",
        "Hash": "9c79206cfed64deb2868cbf0d261fe25475ed4bb8769e17a7713d79ed3ea6018",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能：这是一个AI语音生成组件，通过调用Gradio API将文本转换为语音，支持参考音频的声音特征克隆功能。\\\\n\\\\n代码功能摘要：该组件通过Gradio客户端连接到TTS（文本转语音）API，使用参考音频文件和对应文本来克隆声音特征，将目标文本转换为具有相同声音特色的语音文件，并保存到指定位置。\\\\n\\\\n参数：\\\\n```yaml\\\\ninputs:\\\\n  - name: remove_silence\\\\n    type: boolean\\\\n    required: true\\\\n    description: 是否移除生成音频中的静音部分\\\\n    default: false\\\\n  - name: api_url\\\\n    type: string\\\\n    required: true\\\\n    description: 语音生成API的URL地址\\\\n  - name: ref_audio_filepath\\\\n    type: file\\\\n    required: true\\\\n    description: 参考音频文件路径，用于声音克隆\\\\n  - name: ref_audio_txt\\\\n    type: string\\\\n    required: true\\\\n    description: 参考音频对应的文本内容\\\\n  - name: save_path\\\\n    type: file\\\\n    required: true\\\\n    description: 生成音频文件的保存目录路径\\\\n  - name: gen_name\\\\n    type: string\\\\n    required: true\\\\n    description: 生成音频文件的名称（不含扩展名）\\\\n  - name: gen_text_input\\\\n    type: string\\\\n    required: true\\\\n    description: 需要转换成语音的目标文本内容\\\\n  - name: Speed\\\\n    type: string\\\\n    required: true\\\\n    description: 语音生成的速度参数，范围0.1-2.0\\\\n    default: \\\\\\\"0.3\\\\\\\"\\\\noutputs:\\\\n  - name: result\\\\n    type: string\\\\n    description: 音频生成结果消息，包含成功状态和保存路径信息\\\\n```\\\\n\\\\n运行逻辑：\\\\n- 获取并验证所有输入参数，特别是速度参数的类型转换和范围限制（0.1-2.0）\\\\n- 确保音频保存目录存在，如不存在则自动创建\\\\n- 使用提供的API URL创建Gradio客户端连接\\\\n- 调用TTS API的/basic_tts接口，传入参考音频文件、参考文本、目标文本、静音移除选项、交叉淡化时长和语速参数\\\\n- 检查API返回结果是否为空，如为空则抛出异常\\\\n- 验证生成的音频文件是否实际存在于返回的路径中\\\\n- 将生成的音频文件复制到用户指定的保存路径，并重命名为指定的文件名（.wav格式）\\\\n- 构造成功消息并设置到输出结果中\\\\n- 如果过程中发生任何异常，捕获错误并将错误信息作为结果输出，同时记录到日志中"
    },
    {
        "Filename": "Comfyui_DownLoad.py",
        "Hash": "97fb6e68b4f94c046e4f9e25a5ce126b3bb9773791e2ec1bb13218d042ed759f",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能：这是一个从ComfyUI服务器下载生成图片的节点，可以将ComfyUI生成的图片下载到本地指定路径并保存为PNG格式。\\\\n\\\\n代码功能摘要：通过解析ComfyUI的URL地址，构建图片下载链接，使用HTTP请求获取图片数据，并实现带重试机制的下载功能，最终将图片保存到指定目录。\\\\n\\\\n参数：\\\\n```yaml\\\\ninputs:\\\\n  - name: comfyui_url\\\\n    type: string\\\\n    required: true\\\\n    description: ComfyUI服务器的完整URL地址\\\\n  - name: Save_path\\\\n    type: string\\\\n    required: true\\\\n    description: 图片保存的本地目录路径\\\\n  - name: Picture_name\\\\n    type: string\\\\n    required: true\\\\n    description: 保存图片的文件名（不含扩展名）\\\\noutputs:\\\\n  - name: result\\\\n    type: string\\\\n    description: 下载操作的结果状态，返回\\\"成功\\\"或\\\"失败\\\"\\\\n  - name: Picture_Path\\\\n    type: string\\\\n    description: 保存图片的完整文件路径\\\\n```\\\\n\\\\n运行逻辑：\\\\n- 接收ComfyUI的URL地址、保存路径和图片名称作为输入参数\\\\n- 使用split_url函数解析URL，将其分离为基础URL和查询参数部分\\\\n- 调用download_image_with_retries函数执行带重试机制的图片下载\\\\n- 构建完整的图片下载URL，格式为基础URL + \\\"/fb/api/preview/big/output/\\\" + 图片名称 + \\\"_00001_.png\\\" + 查询参数\\\\n- 创建HTTP会话并发送GET请求获取图片数据\\\\n- 检查HTTP响应状态码，验证Content-Type是否为图片类型\\\\n- 如果下载失败，等待10秒后重试，最多尝试100次\\\\n- 检查保存目录是否存在，不存在则自动创建\\\\n- 清理路径和文件名中的多余空格字符\\\\n- 将图片数据写入本地文件，保存为PNG格式\\\\n- 返回下载结果状态和完整的图片保存路径"
    },
    {
        "Filename": "Comfyui_Generate.py",
        "Hash": "ea1e55e9a0b924d060044433ce3c1ca5090b34f9e4591e399dbfc48e8e353020",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个调用ComfyUI API生成AI图片的组件。通过读取工作流配置文件，设置提示词和图片名称，向ComfyUI服务发送请求来生成AI图片。\\\\n\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n核心功能包括URL解析、工作流文件加载、节点参数配置和API请求发送。主要处理步骤为：解析ComfyUI服务URL、读取JSON格式的工作流配置、修改工作流中的提示词节点和图片保存节点参数、通过HTTP POST请求触发图片生成流程。\\\\n\\\\n参数\\\\n```yaml\\\\ninputs:\\\\n  - name: comfyui_url\\\\n    type: string\\\\n    required: true\\\\n    description: ComfyUI服务的URL地址\\\\n  - name: workflow_file_path\\\\n    type: file\\\\n    required: true\\\\n    description: 工作流配置文件路径，JSON格式\\\\n  - name: prompt\\\\n    type: string\\\\n    required: true\\\\n    description: 生成图片的文本描述提示词\\\\n  - name: Picture_name\\\\n    type: string\\\\n    required: true\\\\n    description: 生成图片的保存文件名前缀\\\\noutputs:\\\\n  - name: result\\\\n    type: string\\\\n    description: 返回图片生成的执行结果状态信息\\\\n```\\\\n\\\\n运行逻辑\\\\n- 接收ComfyUI服务URL并通过split_url函数解析为基础URL和查询参数\\\\n- 使用load_workflow函数读取指定路径的工作流配置文件，解析JSON格式数据\\\\n- 从工作流数据中定位到提示词节点（节点149）和图片保存节点（节点167）\\\\n- 将用户输入的prompt文本赋值给提示词节点的t5xxl输入参数\\\\n- 将用户指定的Picture_name设置为图片保存节点的filename_prefix参数\\\\n- 构造包含完整工作流的JSON数据，通过queue_prompt函数发送POST请求到ComfyUI的/prompt端点\\\\n- 发送请求后返回\\\"生成图片成功\\\"的结果状态信息"
    },
    {
        "Filename": "ConfirmFloderIsAll.py",
        "Hash": "d446717b5b8272d4fccd376a5c7b16617a4f31407b6eb5313b212b6778fcbcc0",
        "NodeKind": "Normal",
        "NodeFunction": "用于确认文件是否存在。\\n\\n输入：文件路径，文件历史路径。\\n\\n输出：布尔值代表文件夹是否齐全,结果，基本路径。"
    },
    {
        "Filename": "Contextadd.py",
        "Hash": "a18b538bccd82ffdf53f3e3756c944c105ef35c6361fc08ceafde591618873be",
        "NodeKind": "LLm",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个大语言模型（LLM）节点，用于处理和分析文本内容，支持字数统计、文本查找和内容提取等功能。该节点可以根据不同的描述模式对输入的提示文本进行处理，并输出相应的结果。\\\\n\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n核心功能包括文本预处理（去除标点符号）、模式匹配识别（支持查找模式和字数统计模式）、文本内容提取和字数统计。主要通过正则表达式匹配特定模式，对ExportPrompt文本进行分析处理，根据不同的描述要求输出对应的文本内容或统计数据。\\\\n\\\\n参数\\\\n```yaml\\\\ninputs: []\\\\noutputs:\\\\n  - name: OutPut1\\\\n    type: string\\\\n    description: 处理后的文本内容或统计结果\\\\n```\\\\n\\\\n运行逻辑\\\\n- 作为LLM节点，该组件可以动态创建输入和输出节点\\\\n- 接收ExportPrompt文本作为处理对象\\\\n- 对输出节点的描述进行模式匹配，识别是否包含查找模式<@find:\\\"...\\\">或字数统计模式<@WordsNum>\\\\n- 如果匹配到查找模式，则在ExportPrompt中搜索指定的文本内容，提取匹配行的后续内容\\\\n- 如果匹配到字数统计模式，则对文本进行标点符号清理，统计去除标点后的字符数量\\\\n- 对于默认输出，会移除ExportPrompt中最后一个\\\"Please\\\"之前的内容，并清理末尾换行符\\\\n- 将处理结果存储到对应的输出节点Context字段中\\\\n- 返回包含所有处理结果的输出数组"
    },
    {
        "Filename": "Contextadd_new.py",
        "Hash": "eb42a32e821f2200f63b31c4d1b3bda7a66c45bc238e9b50e204b87f2adc791e",
        "NodeKind": "LLm",
        "NodeFunction": "Unknown"
    },
    {
        "Filename": "Copy_DeepR1.py",
        "Hash": "b8db0df86ef19ceaccd9759cd7e3d283ef1623de8867006991dbd7ab3ee73bab",
        "NodeKind": "LLm",
        "NodeFunction": "Unknown"
    },
    {
        "Filename": "Copy_DeepV3.py",
        "Hash": "9a208f1771fde5bdfc8c86bb6f3984953c6fc085ca519a03ae5282cf911daf0b",
        "NodeKind": "LLm",
        "NodeFunction": "Unknown"
    },
    {
        "Filename": "CountArray.py",
        "Hash": "ffc7328c6538d5d8494eb1154ffb1d1d22e67144f70384d88c2d6779cbbd3f5f",
        "NodeKind": "ArrayTrigger",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个数组触发器组件，用于生成指定范围内的连续数字序列，为后续节点提供批量的数值输入。\\\\n\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n通过接收起始和结束数字参数，使用for循环遍历指定范围内的每个整数，将每个数字封装成输出节点对象并存储到数组中，最终返回包含完整数字序列的数组。\\\\n\\\\n参数\\\\n```yaml\\\\ninputs:\\\\n  - name: Start_Num\\\\n    type: number\\\\n    required: true\\\\n    description: 数字序列的起始值\\\\n  - name: End_Num\\\\n    type: number\\\\n    required: true\\\\n    description: 数字序列的结束值（包含在序列中）\\\\noutputs:\\\\n  - name: Num\\\\n    type: number\\\\n    description: 生成的数字序列中的每个数字值\\\\n```\\\\n\\\\n运行逻辑（用 - 列表描写详细流程）\\\\n- 从输入节点获取起始数字Start_Num和结束数字End_Num\\\\n- 初始化空数组Array用于存储生成的数字序列\\\\n- 使用for循环遍历从Start_Num到End_Num（包含端点）的每个整数\\\\n- 在每次循环中，将当前数字i赋值给输出节点的Num属性\\\\n- 使用深拷贝将当前输出状态保存到Array数组中，确保每个数组元素都是独立的输出节点对象\\\\n- 循环结束后返回包含完整数字序列的Array数组\\\\n- 返回的数组可供后续节点进行批量处理或循环操作"
    },
    {
        "Filename": "createExcel.py",
        "Hash": "af3e34e31760fe798a806bab1a5adb2a5ea08c770a225a084840dccd5831c02b",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能：这是一个创建空白Excel文件的节点，用于在指定路径下生成新的Excel工作簿文件。\\\\n\\\\n代码功能摘要：接收文件路径和文件名参数，使用openpyxl库创建空白Excel工作簿并保存到指定位置，返回操作结果和完整文件路径。\\\\n\\\\n参数：\\\\n```yaml\\\\ninputs:\\\\n  - name: File_Path\\\\n    type: string\\\\n    required: true\\\\n    description: 指定Excel文件的保存目录路径\\\\n  - name: File_Name\\\\n    type: string\\\\n    required: false\\\\n    description: 要创建的Excel文件名称（可不含.xlsx后缀）\\\\noutputs:\\\\n  - name: Result\\\\n    type: string\\\\n    description: 返回文件创建的执行结果信息\\\\n  - name: File_Path\\\\n    type: string\\\\n    description: 返回新创建Excel文件的完整路径\\\\n```\\\\n\\\\n运行逻辑：\\\\n- 获取输入的文件保存路径和文件名参数\\\\n- 清理文件名中的换行符等特殊字符\\\\n- 检查文件名是否包含.xlsx后缀，如果没有则自动添加\\\\n- 使用os.path.join()将文件路径和文件名组合成完整路径\\\\n- 调用openpyxl.Workbook()创建新的空白Excel工作簿对象\\\\n- 使用workbook.save()方法将工作簿保存到指定的完整路径\\\\n- 如果创建成功，将成功信息和完整文件路径分别赋值给两个输出\\\\n- 如果过程中发生异常，捕获错误并记录到日志，将错误信息输出到Result，File_Path输出为空字符串\\\\n- 返回包含操作结果和文件路径的输出数组"
    },
    {
        "Filename": "createFloder.py",
        "Hash": "0e41982ae8041dc0d90f5efc4062be9e3cc2ff7e34104801568b4b366f06a61c",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能：这是一个文件夹创建节点，用于在指定路径下创建新的文件夹，并返回创建结果和完整路径信息。\\\\n\\\\n代码功能摘要：通过接收目标路径和文件夹名称，使用os.path.join拼接完整路径，检查路径是否存在，如不存在则使用os.makedirs创建文件夹，最后返回操作结果和完整路径。\\\\n\\\\n参数：\\\\n```yaml\\\\ninputs:\\\\n  - name: Floder_Path\\\\n    type: string\\\\n    required: true\\\\n    description: 目标文件夹的父级路径\\\\n  - name: Floder_Name\\\\n    type: string\\\\n    required: true\\\\n    description: 需要创建的文件夹名称\\\\noutputs:\\\\n  - name: Result\\\\n    type: string\\\\n    description: 文件夹创建操作的结果信息\\\\n  - name: Full_Path\\\\n    type: string\\\\n    description: 创建的文件夹的完整路径\\\\n```\\\\n\\\\n运行逻辑：\\\\n- 从输入节点获取目标路径(Floder_path)和文件夹名称(Floder_name)\\\\n- 使用os.path.join将路径和文件夹名称拼接成完整的文件夹路径\\\\n- 通过os.path.exists检查该完整路径是否已存在\\\\n- 如果路径不存在，使用os.makedirs创建新文件夹(包括必要的父级目录)\\\\n- 将操作结果信息格式化为\\\"File saved to {完整路径}\\\"并输出到Result\\\\n- 将完整的文件夹路径输出到Full_Path\\\\n- 返回包含两个输出结果的Outputs数组"
    },
    {
        "Filename": "createTxt.py",
        "Hash": "cc2c041d7b995eefd53e38bfb733311593b38e01a36280d0a0361c5a430d4d0f",
        "NodeKind": "Normal",
        "NodeFunction": "这是一个创建和保存TXT文本文件的组件。\\\\n\\\\n代码功能摘要：该组件接收文件路径、文件名和内容三个输入参数，将内容以UTF-8编码格式保存为.txt文件，并返回保存状态和完整文件路径。\\\\n\\\\n参数：\\\\n```yaml\\\\ninputs:\\\\n  - name: File_Path\\\\n    type: string\\\\n    required: true\\\\n    description: 文件保存的目录路径\\\\n  - name: File_Name\\\\n    type: string\\\\n    required: false\\\\n    description: 要创建的文件名称（不含扩展名）\\\\n  - name: Content\\\\n    type: string\\\\n    required: false\\\\n    description: 要写入文件的文本内容\\\\noutputs:\\\\n  - name: Result\\\\n    type: string\\\\n    description: 文件保存操作的结果状态信息\\\\n  - name: File_Path\\\\n    type: string\\\\n    description: 完整的文件保存路径\\\\n```\\\\n\\\\n运行逻辑：\\\\n- 从输入节点获取文件保存路径、文件名称和文件内容\\\\n- 对文件名进行预处理，移除其中的换行符\\\\n- 将文件路径和文件名拼接，形成完整路径\\\\n- 自动为文件添加.txt扩展名\\\\n- 使用UTF-8编码方式将内容写入到指定文件\\\\n- 输出文件保存成功的状态信息到Result\\\\n- 输出完整的文件保存路径到File_Path"
    },
    {
        "Filename": "DataBase.py",
        "Hash": "f9ee206a48f92fc27b3b41dd833f134d0c41f97c337b2fcbff57833cd39af8d2",
        "NodeKind": "DataBase",
        "NodeFunction": "组件功能：这是一个Excel数据库操作组件，可以对Excel文件进行查询、修改、删除、新增和JSON数据导入等操作。\\\\n\\\\n代码功能摘要：通过读取Excel文件，支持多条件查询（精确/模糊匹配、And/Or逻辑）、数据修改、行删除、新增记录和JSON批量导入等数据库操作，同时保持原有Excel格式和列宽设置。\\\\n\\\\n参数：\\\\n```yaml\\\\ninputs:\\\\n  - name: FilePath\\\\n    type: file\\\\n    required: true\\\\n    description: 需要操作的Excel文件路径\\\\noutputs:\\\\n  - name: Result\\\\n    type: string\\\\n    description: 操作结果和执行摘要信息\\\\n```\\\\n\\\\n运行逻辑：\\\\n- 读取指定路径的Excel文件，加载所有工作表数据并保存原始列宽信息\\\\n- 初始化缓存结构和辅助变量，用于提升多条件查询性能\\\\n- 遍历输出节点配置，解析操作参数（工作表名、查询条件、操作类型等）\\\\n- 根据配置的查询条件生成布尔掩码，支持精确匹配和模糊匹配\\\\n- 实现多条件逻辑组合（And/Or），并使用缓存优化重复查询\\\\n- 根据操作类型执行相应功能：查询返回匹配数据、修改更新指定列值、删除移除符合条件的行、新增添加新记录、JSON导入批量插入数据\\\\n- 处理占位符替换，支持动态参数引用\\\\n- 将修改后的数据写回Excel文件，恢复原有列宽格式\\\\n- 生成操作摘要和调试日志，返回执行结果"
    },
    {
        "Filename": "DataBase_Array.py",
        "Hash": "052272a4d6f605c9999e9514a4ca2f914db5328ead50529fe50bb393ab5839f0",
        "NodeKind": "ArrayTrigger_DataBase",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个Excel文件数据处理节点，用于读取Excel表格数据并按行处理，支持全表格输出或指定列输出两种模式。\\n\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n核心算法基于pandas库读取Excel文件，逐行遍历数据并根据配置的selectBox1参数决定输出格式：当选择\\"
    },
    {
        "Filename": "DeepSeek.py",
        "Hash": "fc752d0a76184bbfa85f54195a839a245130589e698d42602c18700a79f14407",
        "NodeKind": "LLm",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个基于 DeepSeek API 的大语言模型节点，支持文本和图像输入，能够根据系统提示词和用户输入生成智能回复。该组件集成了图像转 Base64 编码、JSON 解析、多种输出格式处理等功能。\\n\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n核心功能包括：图像文件转 Base64 编码处理、构建包含系统提示词和用户输入的消息体、调用 DeepSeek Chat API 进行推理、支持 JSON 格式输出解析和多种数据类型转换、记录 token 使用情况统计。\\n\\n参数\\\\n```yaml\\\\ninputs: []\\\\noutputs:\\\\n  - name: OutPut1\\\\n    type: string\\\\n    description: 模型生成的回复内容\\\\n```\\n\\n运行逻辑\\\\n- 清空并重新初始化输出数组\\\\n- 遍历输入节点，检测文件路径类型的输入并转换为 Base64 编码\\\\n- 根据 OriginalTextSelector 设置构建系统提示词\\\\n- 构建包含系统消息和用户消息的对话数组\\\\n- 将 Base64 编码的图像添加到消息体中\\\\n- 使用 DeepSeek API 密钥初始化 OpenAI 客户端\\\\n- 调用 chat.completions.create 方法进行推理，传入模型参数\\\\n- 获取 API 响应内容\\\\n- 如果输出格式为 JSON，则解析并提取结构化数据\\\\n- 根据输出节点的数据类型进行相应转换和赋值\\\\n- 记录 prompt_tokens、completion_tokens 和 total_tokens 使用情况\\\\n- 返回处理后的输出数组"
    },
    {
        "Filename": "DeepSeekR1.py",
        "Hash": "fd237eff5a25db74f7431f92d279957dc33223be057c6d97d9a1102eef5fc788",
        "NodeKind": "LLm",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个基于 DeepSeek API 的大语言模型节点，支持文本和图像输入的多模态对话功能。该组件可以处理用户的文本提示和图像文件，通过 DeepSeek Reasoner 模型生成智能回复。\\\\n\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n核心功能包括图像文件的 Base64 编码转换、多模态消息构建、DeepSeek API 调用、响应内容的 JSON 格式化处理，以及输出结果的结构化封装。支持原始文本和 JSON 两种输出格式。\\\\n\\\\n参数\\\\n```yaml\\\\ninputs: []\\\\noutputs:\\\\n  - name: OutPut1\\\\n    type: string\\\\n    description: 模型生成的回复内容\\\\n```\\\\n\\\\n运行逻辑\\\\n- 清空并重新初始化输出数组\\\\n- 遍历输入节点，检测文件路径类型的输入\\\\n- 将图像文件转换为 Base64 编码格式\\\\n- 根据原始文本选择器处理导出提示词\\\\n- 构建包含文本和图像的多模态消息数组\\\\n- 使用 DeepSeek API 密钥初始化 OpenAI 客户端\\\\n- 限制最大令牌数不超过 8192\\\\n- 调用 deepseek-reasoner 模型进行对话生成\\\\n- 提取 API 响应中的内容文本\\\\n- 根据输出格式选择器处理响应内容\\\\n- 如果选择 JSON 格式，则解析并格式化 JSON 数据\\\\n- 将处理后的结果分配给相应的输出节点\\\\n- 记录 API 调用的令牌使用统计信息\\\\n- 返回包含生成内容和统计信息的输出数组"
    },
    {
        "Filename": "doubao1.5.py",
        "Hash": "9c127fdb5683c34a7f521b27d0cf02e24378b134272b7b4d031fc64e636b68e5",
        "NodeKind": "LLm",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个豆包大语言模型调用组件，用于与字节跳动的豆包AI模型进行对话交互，支持文本和图像输入，可根据系统提示词和用户提示词生成AI回复。\\\\n\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n该组件通过HTTP请求调用豆包API，支持多模态输入（文本+图像），具备完整的消息构建、API调用、响应解析和JSON格式化功能。核心包含图像Base64编码、消息体构建、API参数配置、响应内容解析和输出格式化等处理流程。\\\\n\\\\n参数\\\\n```yaml\\\\ninputs: []\\\\noutputs:\\\\n  - name: OutPut1\\\\n    type: string\\\\n    description: 豆包模型生成的回复内容\\\\n```\\\\n\\\\n运行逻辑\\\\n- 清空并重新初始化输出数组\\\\n- 遍历输入节点，将图像文件转换为Base64编码格式\\\\n- 根据OriginalTextSelector设置构建系统提示词\\\\n- 构建包含系统消息和用户消息的消息数组\\\\n- 将Base64编码的图像添加到消息数组中\\\\n- 配置豆包API请求参数，包括模型名称、温度、最大令牌数等\\\\n- 发送POST请求到豆包API端点\\\\n- 检查响应状态码，处理API调用异常\\\\n- 解析API响应，提取生成的内容和使用统计信息\\\\n- 根据输出格式选择器处理响应内容（原始文本或JSON格式）\\\\n- 如果是JSON格式，使用专用函数清理和解析JSON内容\\\\n- 将处理后的内容分配给相应的输出节点\\\\n- 记录令牌使用统计信息到输出节点\\\\n- 返回包含所有输出结果的数组"
    },
    {
        "Filename": "doubao1.5_Vision.py",
        "Hash": "ca7e11dd1763fe38bf7788bf6820d069601fbf30eb817e4ddb6982bdc8d6d79e",
        "NodeKind": "LLm",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个豆包大语言模型调用组件，用于通过豆包API进行文本生成和多模态对话，支持文本和图像输入，可根据配置返回原始文本或JSON格式的结构化数据。\\\\n\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n该组件集成豆包API调用功能，支持系统提示词和用户提示词配置，具备图像转Base64编码处理能力，提供多种输出格式选择（原始文本/JSON），并包含完整的JSON解析和清理机制，同时记录token使用情况。\\\\n\\\\n参数\\\\n```yaml\\\\ninputs: []\\\\noutputs:\\\\n  - name: OutPut1\\\\n    type: string\\\\n    description: 豆包模型生成的回答内容\\\\n```\\\\n\\\\n运行逻辑\\\\n- 清空并重新初始化输出数组，准备接收节点配置的输出结构\\\\n- 遍历输入节点，将图像文件转换为Base64编码格式，存储到临时数组中\\\\n- 根据OriginalTextSelector配置构建系统提示词，组合SystemPrompt和ExprotAfterPrompt\\\\n- 构建消息数组，包含系统角色和用户角色的提示内容\\\\n- 将Base64编码的图像添加到消息数组中，支持多模态输入\\\\n- 配置豆包API调用参数，包括模型名称、温度、最大token数、top_p等参数\\\\n- 发送POST请求到豆包API端点，获取模型生成的响应内容\\\\n- 检查API响应状态，如果失败则抛出异常信息\\\\n- 提取响应中的生成内容和token使用统计信息\\\\n- 根据OriginalTextSelector配置选择输出格式处理方式\\\\n- 如果选择JSON格式，则调用字符串转JSON函数进行结构化解析\\\\n- 使用正则表达式和字符串处理技术清理和提取有效的JSON内容\\\\n- 将解析后的结果按照输出节点的数据类型进行分配和转换\\\\n- 记录prompt_tokens、completion_tokens和total_tokens使用情况\\\\n- 返回包含生成内容和统计信息的完整输出数组"
    },
    {
        "Filename": "Esp32_connect.py",
        "Hash": "9c631893ae82fce618a939dc5ba9c688bd8ff89e4e0c99899d4ca9a1146abed2",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个ESP32嵌入式开发节点，用于生成ESP32微控制器的WiFi连接和HTTP通信代码模板。\\\\n\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n接收WiFi连接参数和服务器地址，自动生成包含WiFi连接、HTTP客户端通信功能的完整ESP32 Arduino代码，支持从指定服务器获取控制指令并通过串口输出。\\\\n\\\\n参数\\\\n```yaml\\\\ninputs:\\\\n  - name: WiFi_SSID\\\\n    type: string\\\\n    required: true\\\\n    description: WiFi网络名称\\\\n  - name: WiFi_Password\\\\n    type: string\\\\n    required: true\\\\n    description: WiFi网络密码\\\\n  - name: Server_URL\\\\n    type: string\\\\n    required: true\\\\n    description: 服务器地址，用于获取控制指令\\\\n  - name: Control_Code\\\\n    type: string\\\\n    required: false\\\\n    description: 可选的控制代码或指令类型\\\\noutputs:\\\\n  - name: Result\\\\n    type: string\\\\n    description: 生成的ESP32代码和调试信息\\\\n```\\\\n\\\\n运行逻辑\\\\n- 从输入参数中获取WiFi SSID、密码、服务器URL和可选的控制代码\\\\n- 验证必要参数是否完整，缺少时返回错误信息\\\\n- 收集调试信息，记录所有输入参数\\\\n- 生成ESP32 Arduino代码模板，包含WiFi连接和HTTP客户端功能\\\\n- 代码包含setup函数用于初始化WiFi连接，loop函数用于定期从服务器获取指令\\\\n- 将生成的代码与调试信息合并后输出到Result字段"
    },
    {
        "Filename": "ExcelEventIdNum.py",
        "Hash": "9177b5b4cad7b1f9e3ae1381d39ba7fd545efe55435443891513f79049d57eed",
        "NodeKind": "ArrayTrigger",
        "NodeFunction": "这是用来查找事件的节点。\\n\\n输入：Excel 文件路径。\\n\\n输出：IsWrite 为 Falese 的事件信息并改为True，Edge_Info 为与事件相连的边信息，Adjacent_Node_Info 为与事件相连的节点信息，Event_Id 为事件的 ID。"
    },
    {
        "Filename": "ExcelEventSearch.py",
        "Hash": "1e6c89fa05eefdd69277261fe72f8f6ed08dc2402824865acb86a6c9b0f29b90",
        "NodeKind": "Normal",
        "NodeFunction": "这是用来查找事件的节点。\\n\\n输入：Excel 文件路径，事件 ID。\\n\\n输出：事件信息，边信息，相连的节点信息。"
    },
    {
        "Filename": "ExcelNodeResearch1.py",
        "Hash": "6608e2c24d844b551629cbbf92033c947860bccd544e936c321dd48dec35a9b0",
        "NodeKind": "Normal",
        "NodeFunction": "这是用来精确查找单个Excel 文件中的节点和边的节点。\\n\\n输入：Excel 文件路径，节点名称。\\n\\n输出：节点信息，边信息，相连的节点信息。"
    },
    {
        "Filename": "ExcelNodeResearch2.py",
        "Hash": "bb1ce2f0622fa8343e2918a1963c30c647bb689797e82b7a99c307cd825bb9a2",
        "NodeKind": "Normal",
        "NodeFunction": "这是用来查找模糊查询多个文件中的节点和边的节点。\\n\\n输入：Excel 文件路径，节点名称。\\n\\n输出：节点信息，边信息，相连的节点信息。"
    },
    {
        "Filename": "ExceltoGraphPng.py",
        "Hash": "58c6c27d3e62bb96c4e46ae6ceb9c6185fa1331696cb53a465b3ff4090917bab",
        "NodeKind": "Normal",
        "NodeFunction": "这是用来将Excel文件转换为图形的节点。\\n\\n输入：Excel文件路径。\\n\\n输出：图形可视化的HTML文件路径。"
    },
    {
        "Filename": "FilterWeb.py",
        "Hash": "d6a2e9e83331604f51efb8770fa08785c92322c817ebb9323637d4a6368ad73c",
        "NodeKind": "Normal",
        "NodeFunction": "Unknown"
    },
    {
        "Filename": "Floder_Array.py",
        "Hash": "d94c5aaa521a2f2cc0cc297c230899f9e9a3630537ab62e9584bf8909563e81b",
        "NodeKind": "ArrayTrigger",
        "NodeFunction": "组件功能：这是一个文件夹解析器组件，用于扫描指定文件夹路径下的所有文件，并将文件信息按目录分组整理输出。\\\\n\\\\n代码功能摘要：使用os.walk()递归遍历文件夹，将相同目录下的文件归类到字典中，提取文件名（不含扩展名）和完整路径，最终为每个目录生成包含基础路径、文件映射关系和文件夹名称的格式化字符串输出。\\\\n\\\\n参数：\\\\n```yaml\\\\ninputs:\\\\n  - name: FilePath\\\\n    type: string\\\\n    required: true\\\\n    description: 需要解析的文件夹路径\\\\noutputs:\\\\n  - name: List\\\\n    type: string\\\\n    description: 解析后的文件列表，包含每个文件夹的详细信息\\\\n```\\\\n\\\\n运行逻辑：\\\\n- 接收输入的文件夹路径，首先验证路径是否存在，如果路径不存在则返回错误信息\\\\n- 使用os.walk()遍历指定路径下的所有文件夹和文件，将相同目录下的文件统一归类到字典中\\\\n- 提取每个文件的文件名（不含扩展名）和完整路径，并将路径分隔符统一转换为反斜杠\\\\n- 对每个文件夹生成格式化的字符串输出，包含Basic（文件夹完整路径）、文件名与路径的映射关系、FloderName（当前文件夹名称）\\\\n- 特殊情况处理：如果路径不存在输出错误信息，如果文件夹为空（没有文件）输出提示信息\\\\n- 返回包含所有目录文件信息的数组，每个目录对应一个输出项"
    },
    {
        "Filename": "Genmini15pro.py",
        "Hash": "1d90a5723758a74a85dc7fd44c26e05748b9196a9c1a8bb3978c64cd3ebcee99",
        "NodeKind": "LLm",
        "NodeFunction": "Unknown"
    },
    {
        "Filename": "genmini_new.py",
        "Hash": "104965c3951da2a80a99523a007622329a15653c400aef1fd8bc103a1fe3d8aa",
        "NodeKind": "LLm",
        "NodeFunction": "Unknown"
    },
    {
        "Filename": "GraphPng.py",
        "Hash": "b987c66239085cad97ee3ebdb105120318d7f1ad220cbe4854f8f50e8c281fb6",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个将Markdown格式的图数据转换为可视化网络图的程序，能够解析包含节点和边信息的Markdown文本，并生成交互式的HTML网络图。\\\\n\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n程序通过正则表达式解析Markdown文本，提取节点和边的信息并转换为DataFrame格式，然后使用NetworkX创建有向图结构，最后通过pyvis库生成可交互的HTML网络可视化图。\\\\n\\\\n参数\\\\n```yaml\\\\ninputs:\\\\n  - name: Input1\\\\n    type: string\\\\n    required: true\\\\n    description: Markdown格式的文本数据，包含节点信息和边信息两部分\\\\noutputs:\\\\n  - name: OutPut1\\\\n    type: string\\\\n    description: 输出确认消息，表示网络图已成功创建并保存\\\\n```\\\\n\\\\n运行逻辑\\\\n- 使用正则表达式将输入的Markdown文本按\\\"##\\\"分割成不同章节\\\\n- 解析每个章节，将其转换为DataFrame格式并清理数据（去除多余空格和竖线）\\\\n- 根据章节名称区分节点信息和边信息，分别存储到不同的数组中\\\\n- 使用NetworkX创建有向图对象DiGraph\\\\n- 遍历节点数据，为图添加节点并建立节点标签映射关系\\\\n- 遍历边数据，为图添加边连接关系并建立边标签映射关系\\\\n- 使用pyvis库创建交互式网络图对象\\\\n- 为每个节点添加悬停提示信息，包含节点ID和标签\\\\n- 为每条边添加悬停提示信息，显示关系类型\\\\n- 生成并保存HTML格式的可视化网络图文件\\\\n- 返回确认消息表示图形已成功创建和保存"
    },
    {
        "Filename": "id2json.py",
        "Hash": "7b33d9acb3c4b9cb7eb9bbb7c7b316c5ce52df0d0af8f189b04ec5eb202f823f",
        "NodeKind": "Normal",
        "NodeFunction": "根据id解锁对应的json文档并给出输出"
    },
    {
        "Filename": "IdDown.py",
        "Hash": "295c403bcab03b939e99cdb9e23f97fd1290079534c84916c0a77fac9a2834ad",
        "NodeKind": "Normal",
        "NodeFunction": "特定节点，用于给id降序。\\n\\n输入：name_3_1。\\n\\n输出：name_3_0。"
    },
    {
        "Filename": "IdUp.py",
        "Hash": "b7757f0625835786f675787edbaff4893a3e90145aeed20675126b9977aef011",
        "NodeKind": "Normal",
        "NodeFunction": "特定节点，用于给id升序。\\n\\n输入：name_3_1。\\n\\n输出：name_3_0。"
    },
    {
        "Filename": "IfNode.py",
        "Hash": "a74063dc8f04912c2684e2eff4c8b256ac58162b58d50eb69c5468dd0f5e330b",
        "NodeKind": "IfNode",
        "NodeFunction": "组件功能：这是一个条件判断节点，用于根据配置的多个判断条件对输入参数进行逻辑判断，并输出布尔值结果。\\\\n\\\\n代码功能摘要：该节点支持对String、Number、Boolean三种类型的输入参数进行多条件判断，通过配置判断主体、条件操作符和目标值，实现复杂的业务规则判断。支持And/Or两种逻辑组合方式，可以灵活处理多个条件的组合判断。\\\\n\\\\n参数：\\\\n```yaml\\\\ninputs: []\\\\noutputs:\\\\n  - name: OutPut1\\\\n    type: boolean\\\\n    description: 条件判断的最终结果，true表示条件满足，false表示条件不满足\\\\n```\\\\n\\\\n运行逻辑：\\\\n- 清空并重新初始化输出数组，将所有输出的Boolean值设为False\\\\n- 遍历每个输出节点，提取其配置的判断条件参数：IfLogicSubjectArray（判断主体数组）、IfLogicConditionArray（判断条件数组）、IfLogicContentArray（判断内容数组）、IfLogicKind（逻辑组合方式）\\\\n- 对每组判断条件进行并行处理，根据最小数组长度确定实际处理的条件数量\\\\n- 对于每个判断条件，根据Subject名称在输入数组中查找对应的输入参数\\\\n- 根据输入参数的类型执行相应的判断逻辑：String类型支持include/exclude/empty/not empty判断；Number类型支持>/</==/!=/>=/<= 数值比较；Boolean类型支持true/false判断\\\\n- 收集所有单个条件的判断结果到multi_results数组中\\\\n- 根据IfLogicKind的值进行最终结果计算：\\"
    },
    {
        "Filename": "JinaAi.py",
        "Hash": "4f6ad8a5b94733f436487dc2412c56d9f3e750c39acc99e89cb6e6393b5ce95f",
        "NodeKind": "Normal",
        "NodeFunction": "Unknown"
    },
    {
        "Filename": "JsonSave.py",
        "Hash": "d5c2bb3a67659962e0087005adb8453df0aad606be1089e66006123fee16b098",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n\\\\n这是一个JSON数据处理和保存的节点，用于将输入的内容提取为JSON对象并保存到指定文件路径，支持追加模式和中文内容处理。\\\\n\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n\\\\n核心功能包括：使用正则表达式提取{}包围的JSON对象，清理和标准化文本格式（处理空格和中文标点），将提取内容转换为Python字典，检查目标文件是否存在并支持数据追加，最终以UTF-8编码保存JSON文件。\\\\n\\\\n参数\\\\n\\\\n```yaml\\\\ninputs:\\\\n  - name: FileName\\\\n    type: string\\\\n    required: true\\\\n    description: 需要保存的JSON文件名（会自动添加.json扩展名）\\\\n  - name: FilePath\\\\n    type: string\\\\n    required: true\\\\n    description: JSON文件保存的目标路径\\\\n  - name: Content\\\\n    type: string\\\\n    required: true\\\\n    description: 需要处理和保存的包含JSON对象的内容字符串\\\\noutputs:\\\\n  - name: WebOutput\\\\n    type: string\\\\n    description: 返回操作结果信息，成功时显示保存路径，失败时显示错误信息\\\\n```\\\\n\\\\n运行逻辑\\\\n\\\\n- 从输入节点获取文件名、文件路径和内容参数\\\\n- 清理文件名中的换行符，并确保文件名包含.json扩展名\\\\n- 构建完整的文件保存路径\\\\n- 使用正则表达式提取内容中所有{}包围的JSON对象\\\\n- 对提取的内容进行清理：将多个空格替换为单个空格，将中文标点符号替换为英文标点\\\\n- 将清理后的字符串转换为Python字典对象\\\\n- 检查目标文件是否已存在，如果存在则读取现有数据并与新数据合并\\\\n- 将最终数据序列化为JSON格式，使用UTF-8编码保存到指定文件\\\\n- 返回操作结果，成功时返回保存信息，异常时返回错误信息"
    },
    {
        "Filename": "lastevent.py",
        "Hash": "9669654deb115901945c2119c357faffd0273e49efabe6131fe1c25b47f51d0c",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能：这是一个文本文件读取和内容提取组件，主要用于读取文件并提取其中最后一段被特定分隔符分隔的内容。\\\\n\\\\n代码功能摘要：使用chardet库自动检测文件编码，读取文件内容后查找\\"
    },
    {
        "Filename": "Mcp_stdio_Fetch.py",
        "Hash": "e23329350843969a3f2babf2845b0f8217fd8a97acc44ac91b91fd2daec6f381",
        "NodeKind": "Normal",
        "NodeFunction": "这个程序是一个基于MCP协议的网页内容抓取工具。\\\\n\\\\n代码功能摘要：通过MCP(Message Channel Protocol)协议调用fetcher-mcp工具，异步获取指定URL的网页内容并提取文本信息，支持多种数据格式的统一转换处理。\\\\n\\\\n参数：\\\\n```yaml\\\\ninputs:\\\\n  - name: Input1\\\\n    type: string\\\\n    required: true\\\\n    description: 需要抓取内容的网页URL地址\\\\noutputs:\\\\n  - name: OutPut1\\\\n    type: string\\\\n    description: 抓取到的网页文本内容\\\\n```\\\\n\\\\n运行逻辑：\\\\n- 从输入节点获取目标网页的URL地址\\\\n- 调用make_server_params()函数配置MCP服务器参数，包括设置环境变量、适配Windows和非Windows系统的不同执行命令、设置15秒超时保护\\\\n- 通过MCP_SEVER()异步函数建立与fetcher-mcp工具的连接\\\\n- 在ClientSession中调用fetch_url工具，传入URL参数和extractContent标志\\\\n- 使用to_str()函数处理返回的各种数据格式：bytes类型数据解码、Response对象的text属性提取、content属性处理、可迭代对象的拼接转换\\\\n- 将处理后的文本内容写入输出节点并返回结果"
    },
    {
        "Filename": "Mcp_stdio_Model.py",
        "Hash": "e00ef007de78442cf5a3df520def96cc7d94e7d383d6f8a9a45d500faf88766c",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个基于MCP协议的文件信息获取组件，通过与外部工具通信来获取指定文件的详细信息。\\n\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n组件使用MCP（Message Control Protocol）协议建立与外部工具的通信连接，通过stdio客户端调用get_file_info工具来获取文件信息。核心流程包括配置服务器参数、建立异步会话、调用工具接口并返回文件信息结果。\\n\\n参数\\\\n```yaml\\\\ninputs:\\\\n  - name: Input1\\\\n    type: string\\\\n    required: true\\\\n    description: 需要获取信息的文件路径\\\\noutputs:\\\\n  - name: OutPut1\\\\n    type: string\\\\n    description: 返回的文件信息内容\\\\n```\\n\\n运行逻辑\\\\n- 从输入节点Input1获取目标文件路径\\\\n- 根据操作系统类型配置MCP服务器参数，Windows使用cmd命令，其他系统使用npx命令\\\\n- 设置环境变量和15秒超时时间\\\\n- 建立stdio客户端连接\\\\n- 创建异步客户端会话并初始化\\\\n- 调用get_file_info工具，传入文件路径参数\\\\n- 获取工具返回的文件信息内容\\\\n- 将文件信息结果存储到输出节点OutPut1中\\\\n- 返回包含文件信息的输出数组"
    },
    {
        "Filename": "minico.py",
        "Hash": "d77ccd9eabbb305b32aa94e43339b396400e23c625141a70b1bf995fc9dccd4b",
        "NodeKind": "LLm",
        "NodeFunction": "组件功能（基于GPT-4模型的多模态大语言模型节点，支持文本和图片输入）\\n\\n代码功能摘要（通过HTTP请求调用ChatGPT API，处理文本和图片输入，支持JSON格式化输出和原始文本输出两种模式）\\n\\n参数：\\n```yaml\\ninputs:\\n  - name: SystemPrompt\\n    type: string\\n    required: true\\n    description: 系统提示词，定义AI助手的角色和行为规范\\n  - name: ExprotAfterPrompt\\n    type: string\\n    required: false\\n    description: 导出后的补充提示词，用于增强系统提示\\n  - name: prompt\\n    type: string\\n    required: true\\n    description: 用户输入的问题或对话内容\\n  - name: OriginalTextSelector\\n    type: string\\n    required: true\\n    description: 输出格式选择器，可选值为Json或OriginalText\\n    default: OriginalText\\n    frozen: true\\n  - name: temperature\\n    type: number\\n    required: true\\n    description: 控制输出随机性的温度参数，范围0-2\\n    default: 0.7\\n  - name: max_tokens\\n    type: integer\\n    required: true\\n    description: 最大输出token数量限制\\n    default: 1000\\n  - name: Top_p\\n    type: number\\n    required: true\\n    description: 核采样参数，控制输出多样性\\n    default: 1.0\\n  - name: frequency_penalty\\n    type: number\\n    required: true\\n    description: 频率惩罚参数，减少重复内容\\n    default: 0.0\\n  - name: presence_penalty\\n    type: number\\n    required: true\\n    description: 存在惩罚参数，鼓励谈论新话题\\n    default: 0.0\\noutputs:\\n  - name: OutPut1\\n    type: string\\n    description: 模型返回的回答内容或JSON格式化结果\\n```\\n\\n运行逻辑：\\n- 清空并重新初始化输出数组，复制节点配置的输出结构\\n- 遍历输入数组，检测FilePath类型的输入并转换为base64格式图片数据\\n- 根据OriginalTextSelector参数构建系统提示词，如果选择OriginalText则只使用SystemPrompt\\n- 构建消息数组，包含系统角色消息和用户消息\\n- 将所有base64格式的图片作为用户消息添加到消息数组中\\n- 构建API请求载荷，包含模型参数和消息内容\\n- 设置HTTP请求头，包含授权token和内容类型\\n- 建立HTTPS连接到ChatGPT API服务器并发送POST请求\\n- 接收并解析API响应的JSON数据\\n- 提取模型回复内容到临时变量Temp\\n- 如果选择Json格式输出，使用内置的JSON清理和解析函数处理回复内容\\n- 根据输出格式选择器分配结果到对应的输出字段\\n- 记录API使用的token统计信息到输出结果中\\n- 返回包含处理结果和token统计的输出数组"
    },
    {
        "Filename": "Moviepy.py",
        "Hash": "09d9fc54c96330e7a18f45ab42ceb95c2fdbae86bd84e130eba27c86ca1bb129",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个视频处理节点，主要用于创建或更新视频文件并管理其对应的字幕文件。支持向现有视频追加音频内容，同时自动维护字幕的时间轴同步。\\n\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n核心算法包括视频文件检测与创建、字幕时间轴计算、音频视频拼接处理。主要步骤为：检查目标路径视频文件存在性，不存在则创建空白视频；解析现有字幕文件获取最后时间戳；将新音频转换为黑屏视频片段并拼接到原视频末尾；根据时间轴计算为新内容生成对应字幕条目。\\n\\n参数\\\\n```yaml\\\\ninputs:\\\\n  - name: save_path\\\\n    type: string\\\\n    required: true\\\\n    description: 视频文件保存的目录路径\\\\n  - name: save_name\\\\n    type: string\\\\n    required: true\\\\n    description: 视频文件名称（不含扩展名）\\\\n  - name: use_voice\\\\n    type: string\\\\n    required: false\\\\n    description: 要添加的音频文件路径，为空则不添加音频\\\\n  - name: use_txt\\\\n    type: string\\\\n    required: false\\\\n    description: 要添加到字幕的文本文件路径，为空则不添加字幕\\\\noutputs:\\\\n  - name: result\\\\n    type: string\\\\n    description: 返回处理结果描述，包含更新后的视频和字幕文件路径\\\\n```\\n\\n运行逻辑（用 - 列表描写详细流程）\\\\n- 从输入参数获取保存路径、文件名、音频文件路径和文本文件路径\\\\n- 构建目标视频文件路径和字幕文件路径（.mp4和.srt格式）\\\\n- 检查视频文件是否存在，如不存在则创建一个显示\\\"空白视频\\\"文字的0.5秒短视频\\\\n- 检查字幕文件是否存在，如不存在且提供了文本文件，则创建新字幕文件并写入文本内容\\\\n- 加载现有视频文件为VideoFileClip对象\\\\n- 如果提供了音频文件，加载音频并创建对应时长的黑色背景视频片段\\\\n- 将音频设置到黑色视频片段上，然后与原视频进行拼接\\\\n- 解析现有字幕文件，使用正则表达式提取时间戳，计算最后一个字幕的结束时间\\\\n- 如果提供了文本文件，读取文本内容并计算新字幕的开始和结束时间\\\\n- 将新字幕条目追加到字幕文件末尾，保持时间轴的连续性\\\\n- 保存更新后的视频文件，设置fps为24\\\\n- 返回包含视频和字幕文件路径的结果字符串"
    },
    {
        "Filename": "MoviepyVoiceadd.py",
        "Hash": "573ed1bd5eb1cc564c838ead0710d417b812f4e5bb0e7a456b9dd4647dd10127",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个音视频合成和字幕生成节点，能够将多个音频文件合成为一个视频，并自动生成同步的SRT字幕文件，支持追加模式向现有视频添加新内容。\\\\n\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n核心算法包括：检查现有视频文件并获取时长作为新内容起始点，为每个音频文件创建黑色背景视频片段并添加音频，读取对应文本文件生成SRT格式字幕，在音频片段间添加间隙，最后将所有片段拼接成完整视频并保存。\\\\n\\\\n参数\\\\n```yaml\\\\ninputs:\\\\n  - name: save_path\\\\n    type: string\\\\n    required: true\\\\n    description: 视频和字幕文件的保存路径\\\\n  - name: save_name\\\\n    type: string\\\\n    required: true\\\\n    description: 保存的文件名称（不含扩展名）\\\\n  - name: use_voice\\\\n    type: string\\\\n    required: true\\\\n    description: 音频文件路径列表，支持单个文件或多个文件\\\\n  - name: use_txt\\\\n    type: string\\\\n    required: true\\\\n    description: 对应的文本文件路径列表，用于生成字幕\\\\noutputs:\\\\n  - name: result\\\\n    type: string\\\\n    description: 返回生成的视频和SRT字幕文件的路径信息\\\\n```\\\\n\\\\n运行逻辑\\\\n- 检查保存路径下是否存在同名MP4视频文件，如果存在则获取现有视频时长作为新内容的起始时间点，否则从0开始\\\\n- 将输入的音频文件和文本文件转换为列表格式，确保数据类型一致性\\\\n- 遍历每个音频文件，创建1280x720分辨率的黑色背景视频片段\\\\n- 为每个视频片段添加对应的音频轨道，设置精确的音频时长\\\\n- 读取对应的文本文件内容，如果文件不存在则使用默认文本\\\\n- 计算每个音频片段的开始和结束时间戳，生成SRT格式的字幕条目\\\\n- 在音频片段之间添加0.1秒的静音间隙，避免音频间的突兀切换\\\\n- 将所有视频片段（包括原视频、新音频片段和间隙）按顺序拼接\\\\n- 精确控制最终视频时长，去除多余的0.05秒以确保时长准确\\\\n- 将拼接后的视频以30fps的帧率保存为MP4格式\\\\n- 以追加模式将生成的SRT字幕条目写入字幕文件\\\\n- 返回包含视频文件路径和字幕文件路径的结果信息"
    },
    {
        "Filename": "Mp3ToMp4.py",
        "Hash": "b18a7291d6d23bd70ec6b3b2633ffe8c5a23e1d3eb3ee1a4396bf1377844f770",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能：\\n这是一个将MP3音频文件转换成MP4视频文件的功能组件。该组件将音频文件与一个黑色背景视频结合，生成一个新的MP4视频文件。\\n\\n输入：\\n1. File_Path (String_FilePath类型)：必填，输入MP3音频文件的完整路径\\n2. Save_Path (String_FilePath类型)：必填，输出MP4文件的保存目录路径\\n3. Save_Name (String类型)：必填，指定保存文件的名称\\n\\n输出：\\n- Result (String类型)：转换操作的结果信息，成功时返回转换完成的文件路径，失败时返回错误信息\\n\\n大概的运行逻辑：\\n1. 首先验证输入条件：\\n   - 检查输入的MP3文件是否存在\\n   - 验证文件是否为MP3格式\\n   - 确保保存路径存在，不存在则创建\\n\\n2. 处理输出文件名：\\n   - 如果提供了保存名称，确保具有.mp4后缀\\n   - 如果未提供保存名称，使用原文件名并改为.mp4后缀\\n\\n3. 转换处理：\\n   - 使用AudioFileClip加载MP3音频\\n   - 创建一个640x480像素的黑色背景视频片段\\n   - 将音频与视频合并\\n   - 保存为MP4格式文件\\n\\n4. 结果处理：\\n   - 如果转换成功，输出成功信息和保存路径\\n   - 如果转换失败，输出详细的错误信息\\n\\n整个程序使用try-except结构进行错误处理，确保在转换过程中的任何异常都能被捕获并报告。同时，程序会自动处理文件格式和路径问题，使用户使用更加方便。"
    },
    {
        "Filename": "Mp4AddPic.py",
        "Hash": "85add56c7acf31e1a073cec1a3cfe00d41b8fc9b01fd5c9dc4e4de633fc9dc77",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能：这是一个在MP4视频中添加图片叠加层的视频处理节点，能够在指定时间段内将图片居中显示在视频上。\\\\n\\\\n代码功能摘要：使用FFmpeg工具对视频和图片进行缩放处理，将图片作为叠加层添加到视频的指定时间段内，支持多种时间格式输入和智能时间解析，最终输出处理后的视频文件。\\\\n\\\\n参数：\\\\n```yaml\\\\ninputs:\\\\n  - name: MP4_FilePath\\\\n    type: file\\\\n    required: true\\\\n    description: 需要添加图片的MP4视频文件路径\\\\n  - name: Pic_FilePath\\\\n    type: file\\\\n    required: true\\\\n    description: 要叠加到视频上的图片文件路径\\\\n  - name: StartTime\\\\n    type: string\\\\n    required: true\\\\n    description: 图片开始显示的时间点，支持HH:MM:SS或MM:SS格式\\\\n  - name: EndTime\\\\n    type: string\\\\n    required: true\\\\n    description: 图片结束显示的时间点，支持HH:MM:SS、MM:SS格式或\\\\\\\"END\\\\\\\"表示到视频结束\\\\n  - name: WebInput\\\\n    type: string\\\\n    required: true\\\\n    description: 第五个输入参数（未使用）\\\\noutputs:\\\\n  - name: Result\\\\n    type: string\\\\n    description: 返回处理后的视频文件路径或错误信息\\\\n```\\\\n\\\\n运行逻辑：\\\\n- 获取输入的视频文件路径、图片文件路径和时间参数\\\\n- 对输入的时间字符串进行预处理，将中文冒号转换为英文冒号\\\\n- 使用正则表达式解析时间格式，支持HH:MM:SS和MM:SS两种格式，并处理MM:SS:00误输入情况\\\\n- 验证时间值的有效性，确保分钟和秒数不超过60\\\\n- 检查图片文件是否存在，不存在则抛出异常\\\\n- 将开始时间和结束时间转换为秒数，特殊处理\\\"END\\\"关键字\\\\n- 创建临时输出文件路径，避免直接覆盖原文件\\\\n- 构建FFmpeg命令，设置视频和图片都缩放到1080x1080分辨率\\\\n- 使用filter_complex参数实现图片居中叠加效果，在指定时间段内显示\\\\n- 配置编码参数使用ultrafast预设提高处理速度\\\\n- 执行FFmpeg命令进行视频处理\\\\n- 处理成功后用临时文件替换原始文件\\\\n- 如果处理失败则清理临时文件并抛出详细错误信息\\\\n- 将最终的输出文件路径或错误信息设置到输出参数中"
    },
    {
        "Filename": "Mp4AddSrt.py",
        "Hash": "97bafa1b92ce4c1682f5b5597988288dfa5ae2fb8f834d5366bd63d3f6bd3a70",
        "NodeKind": "Normal",
        "NodeFunction": "这是一个视频字幕添加程序。\\n\\n输入：\\n1. MP4_FilePath (String_FilePath类型) - 视频文件的路径\\n2. Srt_FilePath (String_FilePath类型) - SRT格式字幕文件的路径\\n3. SaveName (String类型) - 输出视频的保存名称\\n\\n输出：\\nResult (String类型) - 处理过程的详细日志信息\\n\\n运行逻辑：\\n1. 程序首先验证输入路径和ImageMagick环境配置\\n2. 通过parse_srt函数解析SRT字幕文件，将其转换为时间戳和文本的列表格式\\n3. 使用VideoFileClip加载原始视频\\n4. create_subtitle_clips函数负责创建电影风格的字幕效果：\\n   - 使用白色字体配黑色描边\\n   - 字幕居中显示在底部\\n   - 支持中文字体(默认微软雅黑)\\n   - 字幕大小自适应视频宽度\\n5. 使用SubtitlesClip将所有字幕片段组合\\n6. 通过CompositeVideoClip将字幕叠加到原视频上\\n7. 最后导出最终视频，保持原视频质量，并提供详细的处理日志\\n\\n特点：\\n- 支持标准SRT字幕格式\\n- 提供专业的电影字幕效果\\n- 保持视频原有质量\\n- 有完善的错误处理机制\\n- 提供详细的处理日志输出\\n\\n注意事项：\\n- 需要正确配置ImageMagick\\n- 输入文件必须存在且格式正确\\n- 输出视频将保存在与输入视频相同的目录下"
    },
    {
        "Filename": "Normal_Model.py",
        "Hash": "14af5eb62894c6ffc2c55f81a3952a4da3e8dc68b8f4e592bc259d4ff67123d3",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个基础的节点模板程序，用于创建具有单一输入和输出的处理节点，可以根据需求自定义输入输出属性和处理逻辑。\\\\n\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n程序定义了一个标准的节点结构模板，包含输入输出节点的初始化、属性配置和基础的运行框架。核心处理逻辑在run_node函数中实现，当前版本仅提供框架结构，具体业务逻辑需要根据实际需求进行填充。\\\\n\\\\n参数\\\\n```yaml\\\\ninputs:\\\\n  - name: Input1\\\\n    type: string\\\\n    required: true\\\\n    description: 输入数据内容\\\\noutputs:\\\\n  - name: OutPut1\\\\n    type: string\\\\n    description: 处理后的输出结果\\\\n```\\\\n\\\\n运行逻辑（用 - 列表描写详细流程）\\\\n- 程序启动时定义输入输出节点数量，当前设置为各1个\\\\n- 初始化输入输出数组，为每个节点分配基础属性包括ID、名称、类型等\\\\n- 配置节点类型为Normal，设置标签属性Label1\\\\n- 为所有输入输出节点指定数据类型为String\\\\n- 执行run_node函数时获取输入节点的Context内容作为file_path\\\\n- 初始化content变量用于存储处理结果，初始化Debugging列表用于调试信息收集\\\\n- 将处理后的content内容赋值给输出节点的Context属性\\\\n- 返回包含处理结果的Outputs数组"
    },
    {
        "Filename": "oneo.py",
        "Hash": "5bc5fb1ce15ef5c1b6bf8ff202ffd1c40731a5e4f3639d078a78623924b5fbaa",
        "NodeKind": "LLm",
        "NodeFunction": "组件功能（简述代码整体功能）\\n这是一个调用大语言模型(LLM)接口的节点程序，通过HTTP请求调用OpenAI API获取AI回复并处理返回结果。\\n\\n代码功能摘要（概括核心算法或主要处理步骤）\\n核心功能是构建HTTP请求调用OpenAI的o1-preview-ca模型，发送用户提示词获取AI回复，支持原始文本和JSON两种输出模式，并提供完整的token使用统计信息。\\n\\n参数\\n```yaml\\ninputs:\\n  - name: ExportPrompt\\n    type: string\\n    required: true\\n    description: 发送给AI的提示词内容\\n  - name: OriginalTextSelector\\n    type: string\\n    required: true\\n    description: 输出模式选择，可选值为OriginalText或Json\\n    default: OriginalText\\n  - name: temperature\\n    type: number\\n    required: true\\n    description: 控制AI回复的随机性，范围0-1\\n    default: 0.7\\n  - name: max_tokens\\n    type: integer\\n    required: true\\n    description: AI回复的最大token数量限制\\n    default: 1000\\n  - name: Top_p\\n    type: number\\n    required: true\\n    description: 核采样参数，控制回复的多样性\\n    default: 1.0\\n  - name: frequency_penalty\\n    type: number\\n    required: true\\n    description: 频率惩罚参数，减少重复内容\\n    default: 0.0\\n  - name: presence_penalty\\n    type: number\\n    required: true\\n    description: 存在惩罚参数，鼓励谈论新话题\\n    default: 0.0\\noutputs:\\n  - name: OutPut1\\n    type: string\\n    description: AI的回复内容，包含prompt_tokens、completion_tokens和total_tokens统计信息\\n```\\n\\n运行逻辑\\n- 清空并重新初始化输出数组，获取节点配置参数\\n- 根据OriginalTextSelector模式处理ExportPrompt，如果是OriginalText模式则截取Please之前的内容\\n- 建立HTTPS连接到api.chatanywhere.com.cn，构建包含模型参数和消息的JSON请求体\\n- 设置请求头包括Authorization Bearer token和Content-Type，发送POST请求到/v1/chat/completions端点\\n- 接收并解析API响应的JSON数据，提取AI回复内容\\n- 如果是Json模式，使用ensure_wrapped_with_braces函数确保JSON格式正确，然后解析为字典对象\\n- 调用process_input_str和clean_input_string等辅助函数处理和清理返回的文本内容\\n- 根据输出模式将结果分配到对应的输出节点：Json模式按键值对分配，OriginalText模式直接赋值\\n- 提取并记录token使用统计信息包括prompt_tokens、completion_tokens和total_tokens\\n- 返回处理完成的Outputs数组，包含AI回复和完整的使用统计"
    },
    {
        "Filename": "PicBounding.py",
        "Hash": "b2ca37991a035b69f97be5707a75e1d878bde80c91533339ebdc38e3d307bb26",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个图像边界框标注组件，用于在图像上绘制文本检测结果的边界框和对应文字。\\\\n\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n该组件接收图片路径和包含文字位置信息的JSON数据，解析JSON中的prism_wordsInfo数组获取文字的多边形边界框坐标和内容，然后使用OpenCV和PIL库在图像上绘制红色边界框和绿色文字标注，最终保存为带有\\\"_annotated\\\"后缀的标注图片。\\\\n\\\\n参数\\\\n```yaml\\\\ninputs:\\\\n  - name: PicPath\\\\n    type: file\\\\n    required: true\\\\n    description: 输入图片文件路径\\\\n  - name: Bounding\\\\n    type: string\\\\n    required: true\\\\n    description: 包含文字位置和内容信息的JSON格式数据\\\\noutputs:\\\\n  - name: Result\\\\n    type: string\\\\n    description: 标注后的图片保存路径\\\\n```\\\\n\\\\n运行逻辑（用 - 列表描写详细流程）\\\\n- 接收输入的图片路径和边界框JSON数据\\\\n- 规范化文件路径，处理双反斜杠等路径问题\\\\n- 检查图片文件是否存在，如不存在则尝试查找大小写不同的同名文件\\\\n- 解析输入的JSON字符串，提取prism_wordsInfo数组中的文字信息\\\\n- 尝试使用OpenCV读取图片，失败则使用PIL读取\\\\n- 如果图片读取失败，根据JSON中的尺寸信息创建空白画布\\\\n- 将OpenCV图像转换为PIL格式以支持中文字体渲染\\\\n- 尝试加载支持中文的系统字体（SimHei、SimSun、Microsoft YaHei等）\\\\n- 遍历每个文字信息，提取多边形边界框坐标点\\\\n- 使用OpenCV在图像上绘制红色多边形边界框\\\\n- 使用PIL在边界框上方绘制绿色文字内容\\\\n- 生成输出文件名，在原文件名后添加\\\"_annotated\\\"后缀\\\\n- 尝试使用OpenCV保存图片，失败则使用PIL保存\\\\n- 验证输出文件是否成功创建且大小不为零\\\\n- 返回标注后图片的完整路径"
    },
    {
        "Filename": "PPtDesign.py",
        "Hash": "a769a4532f34a28cab48ab94223ec6417c3e37df507f13c5e2160689ac31bc5c",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个PPT模板处理节点，主要用于批量修改PPT文件中的文本内容。通过解析替换规则，在PPT的幻灯片、文本框和表格中查找指定关键字并替换为新内容，同时保持原有的文本格式（字体、大小、颜色、加粗等）。支持合并模式，可将新生成的PPT内容添加到现有文件末尾。\\n\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n核心算法包括：1）解析替换规则字符串，提取关键字和替换文本的映射关系；2）遍历PPT中的所有幻灯片、形状、文本框和表格单元格；3）对每个文本段落进行关键字匹配和替换；4）使用深度格式复制技术保留原始文本的字体属性（包括复杂的颜色格式）；5）重构文本runs以维持原有格式；6）支持文件合并功能，使用COM接口处理PPT文件合并。\\n\\n参数\\\\n```yaml\\\\ninputs:\\\\n  - name: PPt_FilePath\\\\n    type: file\\\\n    required: true\\\\n    description: 模板PPT文件的路径\\\\n  - name: Replace_Content\\\\n    type: string\\\\n    required: true\\\\n    description: 替换规则，格式如：\\\"要替换的文本\\\".replace\\\"替换后的文本\\\"，多条规则用##分隔\\\\n  - name: Save_Name\\\\n    type: string\\\\n    required: true\\\\n    description: 保存的文件名\\\\n  - name: Save_Path\\\\n    type: file\\\\n    required: true\\\\n    description: 保存的目标路径\\\\noutputs:\\\\n  - name: Result\\\\n    type: string\\\\n    description: 处理结果的详细日志信息，包含替换统计和错误信息\\\\n```\\n\\n运行逻辑（用 - 列表描写详细流程）\\\\n- 验证输入参数：检查模板PPT文件是否存在，确保保存路径目录存在\\\\n- 解析替换规则：按##分隔符拆分替换规则，使用正则表达式提取关键字和替换文本的映射关系\\\\n- 创建临时文件：复制模板PPT到临时文件进行安全处理\\\\n- 打开PPT文件：使用python-pptx库加载临时PPT文件\\\\n- 遍历幻灯片：对每张幻灯片进行文本处理\\\\n- 处理文本框：检查每个形状是否包含文本框，遍历段落和runs\\\\n- 执行文本替换：在段落文本中查找关键字并替换，统计替换次数\\\\n- 保留文本格式：使用copy_font_color函数精确复制字体属性，包括RGB颜色、主题颜色、方案颜色等\\\\n- 重构文本runs：根据替换结果重新构建文本runs，保持原有格式\\\\n- 处理表格：遍历表格中的每个单元格，对单元格文本执行相同的替换和格式保留操作\\\\n- 文件保存处理：检查目标文件是否存在，如存在则启用合并模式\\\\n- PPT合并：使用COM接口将新PPT内容添加到现有文件末尾\\\\n- 清理资源：删除临时文件，输出详细的处理日志和替换统计信息"
    },
    {
        "Filename": "PyArray.py",
        "Hash": "5fd4b9f01e8791c04f121135543b8836b35517706d1cc4d1dca0732db2856c93",
        "NodeKind": "ArrayTrigger",
        "NodeFunction": "组件功能：这是一个Python文件遍历处理器，主要用于批量读取指定目录下的Python源代码文件，具有文件变更检测功能。\\n\\n代码功能摘要：通过SHA256哈希值比对机制，智能识别目录中已修改或新增的Python文件，避免重复处理未变更的文件，实现高效的批量文件内容读取和路径输出。\\n\\n参数：\\\\ninputs:\\\\n  - name: File_Path\\\\n    type: string\\\\n    required: true\\\\n    description: 需要遍历的目录路径\\\\noutputs:\\\\n  - name: Py_Code\\\\n    type: string\\\\n    description: 读取到的Python文件内容\\\\n  - name: Py_FilePath\\\\n    type: string\\\\n    description: Python文件的完整路径\\\\n  - name: OutPut3\\\\n    type: string\\\\n    description: 调试信息输出\\n\\n运行逻辑：\\\\n- 接收目录路径输入并验证路径有效性\\\\n- 读取目录下的jsonlist.json文件获取已知文件的哈希值映射表\\\\n- 遍历目录下的所有.py文件（仅一级目录，不包含子目录）\\\\n- 计算每个Python文件的SHA256哈希值\\\\n- 将当前哈希值与记录的哈希值进行比较\\\\n- 只处理哈希值不同或新增的文件，跳过未修改的文件\\\\n- 读取符合条件的Python文件内容\\\\n- 为每个处理的文件生成一组输出：文件内容、文件路径和调试信息\\\\n- 使用深拷贝确保输出数据的独立性\\\\n- 返回包含所有处理结果的数组"
    },
    {
        "Filename": "QueryTime.py",
        "Hash": "ed571e0c27b47c2225e362befc22b361707830b90f926edb32a8cd0b800d2c3a",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能：这是一个获取当前日期的功能组件，用于输出格式化的当前系统日期。\\\\n\\\\n代码功能摘要：使用Python的datetime模块获取当前系统时间，并通过strftime方法将其格式化为\\\"YYYY-MM-DD\\\"格式的日期字符串输出。\\\\n\\\\n参数：\\\\n```yaml\\\\ninputs: []\\\\noutputs:\\\\n  - name: OutPut1\\\\n    type: string\\\\n    description: 格式为\\\"YYYY-MM-DD\\\"的当前日期字符串\\\\n```\\\\n\\\\n运行逻辑：\\\\n- 调用datetime.now()方法获取当前系统时间\\\\n- 使用strftime(\\"
    },
    {
        "Filename": "QuestionExceel.py",
        "Hash": "83493168eca1bb3fc59bf7a1ef81065ac978e97e79e3810f645292d37c30ec6b",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能（简述代码整体功能）\\n这是一个Excel题库生成器节点，用于将题目信息按照标准格式写入Excel文件中，支持多选项题目的批量管理和存储。\\n\\n代码功能摘要（概括核心算法或主要处理步骤）\\n程序通过openpyxl库操作Excel文件，检查目标文件是否存在并创建或打开工作表，然后将题目、选项、答案等信息按照预定义的列格式写入Excel的新行中，最后保存文件并返回执行状态。\\n\\n参数\\n```yaml\\ninputs:\\n  - name: 题目\\n    type: string\\n    required: true\\n    description: 题干内容\\n  - name: 答案\\n    type: string\\n    required: true\\n    description: 正确答案\\n  - name: 选项A\\n    type: string\\n    required: true\\n    description: 第一个选项内容\\n  - name: 选项B\\n    type: string\\n    required: true\\n    description: 第二个选项内容\\n  - name: 选项C\\n    type: string\\n    required: true\\n    description: 第三个选项内容\\n  - name: 选项D\\n    type: string\\n    required: true\\n    description: 第四个选项内容\\n  - name: 选项E\\n    type: string\\n    required: true\\n    description: 第五个选项内容\\n  - name: 选项F\\n    type: string\\n    required: true\\n    description: 第六个选项内容\\n  - name: 选项G\\n    type: string\\n    required: true\\n    description: 第七个选项内容\\n  - name: 题目类型\\n    type: string\\n    required: true\\n    description: 题目的分类标识\\n  - name: 路径\\n    type: file\\n    required: true\\n    description: Excel文件的保存路径\\noutputs:\\n  - name: OutPut1\\n    type: string\\n    description: 执行结果状态，成功时返回Success\\n```\\n\\n运行逻辑\\n- 获取输入的Excel文件路径和所有题目相关信息\\n- 检查指定路径的Excel文件是否存在\\n- 如果文件不存在，创建新的Excel工作簿并设置Sheet1工作表\\n- 如果文件存在，打开现有文件并确保包含Sheet1工作表\\n- 查找Excel表格中的最后一行，确定新数据的插入位置\\n- 按照预定格式将数据写入对应列：A列写入题目内容，B列写入题目类型，C到I列依次写入7个选项，M列写入正确答案\\n- 保存修改后的Excel文件\\n- 返回执行成功状态Success"
    },
    {
        "Filename": "QvQ_Vl_Max.py",
        "Hash": "fbcb12a2457771eb699b71f562105a2a836148d443cead57642f7f366f6f98d3",
        "NodeKind": "LLm",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个基于阿里云通义千问QVQ-Max模型的大语言模型节点，支持文本和图像的多模态输入处理，能够进行推理思考并生成回答。\\\\n\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n该组件通过OpenAI兼容接口调用阿里云通义千问QVQ-Max模型，支持图像文件转Base64编码后与文本一起发送给模型，采用流式响应处理，能够分别捕获模型的推理过程和最终答案，并根据配置以原始文本或JSON格式输出结果。\\\\n\\\\n参数\\\\n```yaml\\\\ninputs: []\\\\noutputs:\\\\n  - name: OutPut1\\\\n    type: string\\\\n    description: 模型生成的回答内容\\\\n```\\\\n\\\\n运行逻辑\\\\n- 清空并重新初始化输出数组\\\\n- 遍历输入节点，将图像文件转换为Base64编码格式\\\\n- 根据OriginalTextSelector配置处理导出提示词\\\\n- 构建包含文本和图像的消息数组\\\\n- 使用OpenAI客户端连接阿里云通义千问API\\\\n- 限制max_tokens不超过8192\\\\n- 发起流式聊天完成请求\\\\n- 分别处理推理内容和回答内容的流式响应\\\\n- 实时打印推理过程和完整回复\\\\n- 根据OriginalTextSelector配置选择输出格式（原始文本或JSON）\\\\n- 如果是JSON格式，解析并分配到对应的输出节点\\\\n- 保存推理内容和token使用统计信息到输出结果\\\\n- 返回处理后的输出数组"
    },
    {
        "Filename": "Qw72B.py",
        "Hash": "efec2b62e806b5ec9aad30ce0ba37e2e2cb50f74a1394053b2db839e4ce8143c",
        "NodeKind": "LLm",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个基于阿里云通义千问模型的大语言模型节点，支持文本和图像输入，能够根据系统提示词和用户输入生成智能回复。\\n\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n该节点通过OpenAI兼容接口调用通义千问模型，支持图像转Base64编码处理，具备JSON格式输出解析功能，并提供完整的token使用统计信息。\\n\\n参数\\\\n```yaml\\\\ninputs:\\\\n  - name: 可动态创建输入节点\\\\n    type: string\\\\n    required: false\\\\n    description: 支持文本和图像文件输入，图像会自动转换为Base64格式\\\\noutputs:\\\\n  - name: OutPut1\\\\n    type: string\\\\n    description: 模型生成的回复内容，支持原始文本或JSON格式输出\\\\n```\\n\\n运行逻辑\\\\n- 清空并重新初始化输出数组\\\\n- 遍历输入节点，检测图像文件并转换为Base64编码\\\\n- 根据OriginalTextSelector设置构建系统提示词\\\\n- 组装消息数组，包含系统提示、用户输入和图像内容\\\\n- 调用阿里云通义千问API，传入温度、最大token数、top_p等参数\\\\n- 获取模型响应并提取内容\\\\n- 如果选择JSON模式，使用内置JSON解析器处理响应\\\\n- 清理和格式化JSON内容，去除代码块标记和控制字符\\\\n- 根据输出节点类型分配解析后的数据\\\\n- 记录prompt_tokens、completion_tokens和total_tokens使用情况\\\\n- 返回包含生成内容和统计信息的输出数组"
    },
    {
        "Filename": "QwQ32B.py",
        "Hash": "0f7a7d9f5600a311f570092b4e9dce8f703352c75d5a029136eeb35880b1e512",
        "NodeKind": "LLm",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个基于阿里云通义千问模型的大语言模型节点，支持文本和图像输入，能够根据系统提示词和用户输入生成智能回复。\\\\n\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n该组件通过OpenAI兼容接口调用阿里云通义千问deepseek-r1-distill-qwen-32b模型，支持图像转Base64编码处理，可配置温度、最大令牌数等参数，并提供JSON格式输出解析功能。\\\\n\\\\n参数\\\\n```yaml\\\\ninputs: []\\\\noutputs:\\\\n  - name: OutPut1\\\\n    type: string\\\\n    description: 模型生成的回复内容\\\\n```\\\\n\\\\n运行逻辑\\\\n- 清空并重新初始化输出数组\\\\n- 遍历输入节点，检测文件路径类型的输入并转换为Base64编码\\\\n- 根据OriginalTextSelector配置构建系统提示词\\\\n- 组装包含系统提示词和用户输入的消息数组\\\\n- 将Base64编码的图像添加到消息中\\\\n- 使用OpenAI客户端调用阿里云通义千问API\\\\n- 限制最大令牌数不超过8192\\\\n- 获取模型响应内容\\\\n- 根据OriginalTextSelector判断是否需要JSON解析\\\\n- 如果是JSON模式，使用正则表达式清理和解析响应\\\\n- 将解析结果分配给对应的输出节点\\\\n- 记录令牌使用统计信息\\\\n- 返回处理后的输出数组"
    },
    {
        "Filename": "QwQ7B.py",
        "Hash": "201d055e8b5390348d70622c3db40507f492abd1f476a38b3feef8336b90286f",
        "NodeKind": "LLm",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个基于阿里云通义千问2.5-7B模型的大语言模型节点，支持文本和图像输入，能够根据系统提示词和用户输入生成智能回复。\\\\n\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n该节点通过OpenAI兼容接口调用通义千问模型，支持图像转Base64编码处理，具备JSON格式输出解析功能，并提供完整的token使用统计。核心处理包括消息构建、API调用、响应解析和输出格式化。\\\\n\\\\n参数\\\\n```yaml\\\\ninputs: []\\\\noutputs:\\\\n  - name: OutPut1\\\\n    type: string\\\\n    description: 模型生成的回复内容\\\\n```\\\\n\\\\n运行逻辑\\\\n- 清空并重新初始化输出数组\\\\n- 遍历输入节点，检测文件路径类型的输入并转换为Base64编码\\\\n- 根据OriginalTextSelector设置构建系统提示词\\\\n- 构建包含系统消息和用户消息的对话数组\\\\n- 将Base64编码的图像添加到消息中\\\\n- 使用OpenAI客户端调用通义千问API，设置温度、最大token数等参数\\\\n- 获取模型响应内容\\\\n- 根据OriginalTextSelector判断是否需要JSON解析\\\\n- 如果是JSON模式，使用正则表达式清理和解析响应\\\\n- 将解析后的内容分配给对应的输出节点\\\\n- 记录API调用的token使用情况\\\\n- 返回包含生成内容和统计信息的输出数组"
    },
    {
        "Filename": "QwQ_Plus.py",
        "Hash": "e5a2b1efe7194da99cd166cd8f958f630f6e09bbf70f331986f24c77d846b1f2",
        "NodeKind": "LLm",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个基于阿里云通义千问QWQ-Plus模型的大语言模型节点，支持文本和图像输入，能够进行推理思考并生成回答。\\n\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n该组件通过OpenAI兼容接口调用阿里云通义千问QWQ-Plus模型，支持图像转Base64编码处理，具备流式输出和推理过程展示功能，可根据配置输出原始文本或JSON格式结果。\\n\\n参数\\\\n```yaml\\\\ninputs:\\\\n  - name: 动态输入\\\\n    type: string\\\\n    required: false\\\\n    description: 可动态创建多个输入节点，支持文本和图像文件输入\\\\noutputs:\\\\n  - name: OutPut1\\\\n    type: string\\\\n    description: 模型生成的回答内容，可包含推理过程和token使用统计\\\\n```\\n\\n运行逻辑（用 - 列表描写详细流程）\\\\n- 清空并重新构建输出数组，准备接收节点配置的输出格式\\\\n- 遍历输入节点，识别图像文件类型输入并转换为Base64编码格式\\\\n- 根据OriginalTextSelector配置构建系统提示词，合并SystemPrompt和ExprotAfterPrompt\\\\n- 构建消息数组，包含系统角色提示和用户问题，添加Base64编码的图像内容\\\\n- 初始化OpenAI客户端，配置阿里云通义千问API端点和密钥\\\\n- 限制max_tokens参数不超过8192，调用chat.completions.create进行流式生成\\\\n- 处理流式响应，分别收集推理过程(reasoning_content)和最终回答(content)\\\\n- 实时打印思考过程和完整回复，提供用户交互体验\\\\n- 根据OriginalTextSelector配置处理输出格式，支持原始文本或JSON解析\\\\n- 如果选择JSON格式，使用正则表达式清理和验证JSON结构\\\\n- 将处理后的结果分配到对应的输出节点，支持字符串、数字、布尔值类型\\\\n- 保存推理内容和token使用统计信息到输出节点\\\\n- 返回包含所有输出结果的数组，供后续节点使用"
    },
    {
        "Filename": "QwVl.py",
        "Hash": "15f51207bfd0cd73284be574e2e9237741f1e5797ca3715bbcbe18f3bb8d24cd",
        "NodeKind": "LLm",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个基于阿里云通义千问视觉语言模型的AI对话节点，支持文本和图像的多模态输入处理，能够根据系统提示词和用户输入生成智能回复。\\\\n\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n该组件通过OpenAI兼容接口调用通义千问2.5-VL模型，将输入的图像文件转换为Base64编码后与文本提示一起发送给模型，支持JSON格式和原始文本两种输出模式，并提供完整的token使用统计信息。\\\\n\\\\n参数\\\\n```yaml\\\\ninputs: []\\\\noutputs:\\\\n  - name: OutPut1\\\\n    type: string\\\\n    description: 模型生成的回复内容\\\\n```\\\\n\\\\n运行逻辑\\\\n- 清空并重新初始化输出数组\\\\n- 遍历输入节点，识别图像文件类型的输入\\\\n- 将图像文件转换为Base64编码格式\\\\n- 根据OriginalTextSelector设置构建系统提示词\\\\n- 构建包含系统提示、用户提示和图像数据的消息数组\\\\n- 使用OpenAI客户端调用阿里云通义千问2.5-VL模型接口\\\\n- 设置模型参数包括温度、最大token数、top_p等\\\\n- 获取模型响应内容\\\\n- 根据输出格式选择器处理响应：JSON格式则解析并分配到对应输出，原始文本则直接输出\\\\n- 记录token使用情况包括输入token、输出token和总token数\\\\n- 返回处理后的输出结果"
    },
    {
        "Filename": "Rag.py",
        "Hash": "d55a304569b823cd32b0bd2f6fb2c2bbbe867c804ffa5483e05cfa306ecbf593",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能（简述代码整体功能）\\n这是一个基于语义向量的文本搜索组件，通过阿里云DashScope的text-embedding-v3模型对JSONL格式的文本数据进行语义相似度搜索和排序。支持多个查询词，使用**分隔。\\n\\n代码功能摘要（概括核心算法或主要处理步骤）\\n核心算法采用向量余弦相似度计算，先读取JSONL文件并根据项目名称进行预筛选，然后使用DashScope API将查询文本和候选文本转换为向量，计算相似度并按分数降序排列，最终返回符合阈值要求的前N个结果。支持多个查询词，分别计算并输出结果。\\n\\n参数\\n```yaml\\ninputs:\\n  - name: Json_Path\\n    type: file\\n    required: true\\n    description: 包含待搜索文本数据的JSONL格式文件路径\\n  - name: Select_item\\n    type: string\\n    required: true\\n    description: 用于预筛选的项目名称，支持逗号分隔多个关键词，当为\\\"All\\\"时跳过筛选\\n  - name: query\\n    type: string\\n    required: true\\n    description: 用户输入的搜索查询文本，支持**分隔多个查询词\\n  - name: Rank\\n    type: integer\\n    required: true\\n    description: 返回搜索结果的最大数量\\n  - name: Min_Score\\n    type: number\\n    required: true\\n    description: 相似度分数的最小阈值，低于此值的结果将被过滤\\noutputs:\\n  - name: Result\\n    type: string\\n    description: 包含调试信息和格式化搜索结果的完整文本输出\\n```\\n\\n运行逻辑\\n- 读取并验证输入参数，检查JSONL文件是否存在\\n- 逐行解析JSONL文件内容，将每行转换为JSON对象\\n- 根据Select_item参数对数据进行预筛选，保留ID中包含指定关键词的条目，若Select_item为\\\"All\\\"不做筛选\\n- 提取所有候选文本内容，准备进行向量化处理\\n- 调用DashScope的text-embedding-v3模型，将查询文本和候选文本批量转换为向量\\n- 计算查询向量与每个候选向量的余弦相似度分数\\n- 按相似度分数降序排列所有结果，取前Rank个候选项\\n- 应用Min_Score阈值过滤，只保留相似度大于等于阈值的结果\\n- 格式化输出结果，包含序号、ID、相似度分数和文本片段预览\\n- 如果没有符合条件的结果，返回相应的提示信息\\n- 将调试信息和搜索结果合并，生成最终的输出文本"
    },
    {
        "Filename": "reader.py",
        "Hash": "44296ffe89173f92276868620a1f5c81cd11a7338001b17175f7e958eaed6311",
        "NodeKind": "Normal",
        "NodeFunction": "Unknown"
    },
    {
        "Filename": "SearchWeb.py",
        "Hash": "234702358a36e685b82579f6e53facdb0934d25e3801687bb3d259f749184adf",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能：这是一个网页内容转Markdown格式转换器，用于将指定URL的网页内容抓取并转换为Markdown格式文本。\\\\n\\\\n代码功能摘要：通过HTTP请求获取网页HTML内容，使用markdownify库将HTML转换为Markdown格式，转换过程中会移除script和style标签，将标题转为ATX格式，列表转为星号格式。\\\\n\\\\n参数：\\\\n```yaml\\\\ninputs:\\\\n  - name: WebInput\\\\n    type: string\\\\n    required: true\\\\n    description: 需要转换的网页URL地址\\\\noutputs:\\\\n  - name: WebOutput\\\\n    type: string\\\\n    description: 转换后的Markdown格式文本内容\\\\n```\\\\n\\\\n运行逻辑：\\\\n- 从输入节点获取网页URL地址\\\\n- 设置User-Agent请求头模拟浏览器访问，避免被网站拦截\\\\n- 使用requests库发送GET请求获取目标网页的HTML内容\\\\n- 调用response.raise_for_status()确保请求成功，如有错误则抛出异常\\\\n- 使用markdownify库将获取的HTML内容转换为Markdown格式\\\\n- 转换时配置heading_style为ATX格式（使用#号表示标题）\\\\n- 设置strip参数移除script和style标签内容\\\\n- 设置bullets参数将列表项转换为星号格式\\\\n- 将转换完成的Markdown内容存储到输出节点中\\\\n- 返回包含转换结果的输出数组"
    },
    {
        "Filename": "segemenTxt.py",
        "Hash": "27db6a5185c2950f13b717115cae77456713e5fcc9a7e0fae00a68582fb69992",
        "NodeKind": "Normal",
        "NodeFunction": "这是用来创建分割文本的会按照。或换行分割文本的节点。\\n\\n输入：文件内容。\\n\\n可创建输出节点：按照输出节点均等风切割文本。\\n\\n输出：分割后的文本。"
    },
    {
        "Filename": "segemenTxt500.py",
        "Hash": "cd9e31b3f11a1cf016d99f7f14308aabcd4783723870cee0d4a07053810995d7",
        "NodeKind": "Normal",
        "NodeFunction": "这是用来创建分割文本的会按照。或换行分割文本的节点。\\n\\n输入：文件内容。\\n\\n可创建输出节点：按照输出节点均等风切割文本。\\n\\n输出：分割后的文本。"
    },
    {
        "Filename": "segemenTxttoReader.py",
        "Hash": "5bf8b9c587b2519f5ec74903e8b419a93c05476281ee7f5e55d6ce97df6dbe80",
        "NodeKind": "Normal",
        "NodeFunction": "这是用来创建分割文本将文本转化成字幕的节点。\\n\\n输入：文件内容。\\n\\n输出：分割后的文本。"
    },
    {
        "Filename": "SendMessage.py",
        "Hash": "cb09be861a5e2ade835c352928aabe15360c09c94b74d39701ec01591b2efd28",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能：这是一个HTTP消息发送节点，通过POST请求向本地服务器发送消息并返回响应结果。\\\\n\\\\n代码功能摘要：接收消息内容和接收者信息两个输入参数，将其组装成JSON格式数据，通过HTTP POST请求发送到本地服务器(http://localhost:5111/send)，处理响应并返回JSON格式的结果。\\\\n\\\\n参数：\\\\n```yaml\\\\ninputs:\\\\n  - name: Input1\\\\n    type: string\\\\n    required: true\\\\n    description: 要发送的消息内容\\\\n  - name: Input2\\\\n    type: string\\\\n    required: true\\\\n    description: 消息接收者信息\\\\noutputs:\\\\n  - name: OutPut1\\\\n    type: string\\\\n    description: HTTP请求的响应结果(JSON格式字符串)\\\\n```\\\\n\\\\n运行逻辑：\\\\n- 从输入参数中获取消息内容(Input1)和接收者信息(Input2)\\\\n- 将两个输入参数组装成JSON格式的请求数据：{\\"
    },
    {
        "Filename": "Send_Message_TeamWork.py",
        "Hash": "7d723bf66fdb4789480e8756cf3fd7b6e3fd59f433b7c307175b72a1e3d18e2d",
        "NodeKind": "Normal_TeamWork",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个TeamWork消息发送节点，用于在TeamWork系统中实现不同代理之间的HTTP消息通信功能。\\\\n\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n通过HTTP POST请求将消息发送到指定服务器端点，构建包含接收者、消息内容、限制标志和发送者信息的JSON数据包，并处理请求响应或异常情况。\\\\n\\\\n参数\\\\n```yaml\\\\ninputs:\\\\n  - name: port\\\\n    type: string\\\\n    required: true\\\\n    description: 消息发送的目标服务器端口\\\\n  - name: AgentName\\\\n    type: string\\\\n    required: true\\\\n    description: 发送消息的代理名称\\\\n  - name: To\\\\n    type: string\\\\n    required: true\\\\n    description: 消息的接收者\\\\n  - name: Message\\\\n    type: string\\\\n    required: true\\\\n    description: 要发送的消息内容\\\\n  - name: IsLimite\\\\n    type: boolean\\\\n    required: true\\\\n    description: 是否有发送限制的标志位\\\\noutputs:\\\\n  - name: Result\\\\n    type: string\\\\n    description: 消息发送的结果，包含成功状态或错误信息\\\\n```\\\\n\\\\n运行逻辑\\\\n- 从输入节点获取5个参数：服务器端口、代理名称、接收者、消息内容和限制标志\\\\n- 使用端口号构建完整的HTTP请求URL（http://{port}/send_message）\\\\n- 设置HTTP请求头为JSON格式（Content-Type: application/json）\\\\n- 将输入参数组织成JSON数据包，包含to（接收者）、content（消息内容）、is_limite（限制标志）和From（发送者）字段\\\\n- 通过requests.post方法发送HTTP POST请求到目标服务器\\\\n- 调用response.raise_for_status()检查HTTP响应状态\\\\n- 如果请求成功，从响应JSON中提取status字段作为结果，若无status字段则返回默认成功消息\\\\n- 如果请求过程中发生RequestException异常，捕获异常并格式化错误信息\\\\n- 将最终结果（成功状态或错误信息）赋值给输出节点Result的Context字段\\\\n- 返回包含处理结果的Outputs数组"
    },
    {
        "Filename": "SpeakAddSound.py",
        "Hash": "f850f30fae89b997731ed395e6ef23bb971a7666f69dcafc6083a16e512b078a",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能\\\\n这是一个音频合成处理节点，主要用于将多个音效按照指定时间点插入到主音频中，并进行音量调整和保存。\\\\n\\\\n代码功能摘要\\\\n该节点通过解析音效配置文本，提取音效名称和时间信息，在指定文件夹中查找对应的音效文件，然后将这些音效按时间轴合成到主音频中。支持多种时间格式解析和音频格式处理，使用临时文件机制解决中文路径问题，最终输出高质量的合成音频文件。\\\\n\\\\n参数\\\\n```yaml\\\\ninputs:\\\\n  - name: Voice_path\\\\n    type: file\\\\n    required: true\\\\n    description: 主音频文件路径\\\\n  - name: Soundtxt\\\\n    type: string\\\\n    required: true\\\\n    description: 音效配置文本，使用**^^**分隔不同音效段\\\\n  - name: Sound_Path\\\\n    type: file\\\\n    required: true\\\\n    description: 音效文件所在文件夹路径\\\\n  - name: Save_path\\\\n    type: file\\\\n    required: true\\\\n    description: 合成后音频的保存文件夹路径\\\\n  - name: Save_name\\\\n    type: string\\\\n    required: true\\\\n    description: 合成后音频的文件名\\\\n  - name: Volume\\\\n    type: string\\\\n    required: true\\\\n    description: 音效的音量大小（数字格式）\\\\noutputs:\\\\n  - name: result\\\\n    type: string\\\\n    description: 处理结果信息，包括成功保存路径或错误信息\\\\n```\\\\n\\\\n运行逻辑\\\\n- 验证输入参数的有效性，包括文件路径存在性和音量值的数字格式\\\\n- 加载主音频文件，检查文件是否可正常读取\\\\n- 解析音效配置文本，使用**^^**分隔符将其分割成独立的音效信息段\\\\n- 对每个音效段提取音效名称和时间点信息，支持多种时间格式（HH:MM:SS、MM:SS、SS）\\\\n- 在音效文件夹中查找匹配的音效文件，支持mp3、wav、ogg等格式\\\\n- 加载找到的音效文件并设置其开始时间、音量和最大时长限制（5秒）\\\\n- 验证所有音效的时间轴是否在主音频时长范围内，过滤无效音效\\\\n- 使用CompositeAudioClip将主音频和所有有效音效合成为最终音频\\\\n- 创建临时文件处理中文路径问题，设置输出音频质量（44.1kHz采样率，192k比特率）\\\\n- 将临时文件移动到指定保存位置，确保目标目录存在\\\\n- 清理所有音频资源，返回处理结果信息"
    },
    {
        "Filename": "SrtSub.py",
        "Hash": "0aa1e16a10057660b8e679645242755c0efdf87a2c4b555119ea47119556c7a1",
        "NodeKind": "Normal",
        "NodeFunction": "输入srt，和中止的时间轨道，输出剪辑后的srt"
    },
    {
        "Filename": "TeamWorkTrigger.py",
        "Hash": "c0ed490880c38d3ef33c8c17adc896a019dd8602b5d6663e8cfeb1d3c3e12199",
        "NodeKind": "passivityTrigger",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个消息触发器节点，用于从TeamWork系统获取指定代理的未回复消息，实现自动化消息监控和处理。\\\\n\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n通过HTTP POST请求向指定的Flask服务器发送代理名称，获取该代理的所有未回复消息，并将每条消息的发送者、内容和历史记录分别输出到三个端口。支持批量消息处理，对每条消息生成一组完整的输出结果。\\\\n\\\\n参数\\\\n```yaml\\\\ninputs:\\\\n  - name: HostPort\\\\n    type: string\\\\n    required: true\\\\n    description: Flask应用的主机地址和端口号\\\\n  - name: AgentName\\\\n    type: string\\\\n    required: true\\\\n    description: 需要获取消息的代理名称\\\\noutputs:\\\\n  - name: From\\\\n    type: string\\\\n    description: 消息的发送者信息\\\\n  - name: NewMessage\\\\n    type: string\\\\n    description: 新接收到的消息内容\\\\n  - name: HistoryMessage\\\\n    type: string\\\\n    description: 相关的历史消息记录\\\\n```\\\\n\\\\n运行逻辑\\\\n- 验证输入参数HostPort和AgentName是否存在，缺失则输出错误信息并返回None\\\\n- 构建API请求URL：\\\\\\\"http://{HostPort}/get_messages\\\\\\\"\\\\n- 设置HTTP请求头为JSON格式，准备包含agent_name的请求数据\\\\n- 向目标URL发送POST请求，传递代理名称参数\\\\n- 接收服务器返回的JSON响应，包含指定代理的所有未回复消息\\\\n- 检查返回的消息列表是否为空，为空则输出提示信息并返回None\\\\n- 对每条消息进行处理：创建输出数组的深拷贝，避免数据覆盖\\\\n- 从每条消息中提取From（发送者）、context（消息内容）、History（历史记录）三个字段\\\\n- 将提取的数据分别赋值给三个输出端口：From、NewMessage、HistoryMessage\\\\n- 输出调试信息显示当前处理的消息详情\\\\n- 将每组输出结果添加到返回数组中，实现多消息批量输出\\\\n- 异常处理包括网络请求错误和JSON解析错误，出错时输出相应错误信息并返回None"
    },
    {
        "Filename": "txttrriger.py",
        "Hash": "9ad17f664bb1adb96e6c8d7e0cdec95573eb53a44d54b5e6fa09582a4863edca",
        "NodeKind": "ArrayTrigger",
        "NodeFunction": "这是一个文本分割处理节点，用于读取文件并按指定分隔符将内容分割成多个片段进行批量处理。\\\\n\\\\n该节点实现了智能文件读取和灵活的文本分割功能，支持多种编码格式和自定义分割模式，将单个文件内容转换为可逐一处理的文本片段数组。\\\\n\\\\n```yaml\\\\ninputs:\\\\n  - name: file_path\\\\n    type: file\\\\n    required: true\\\\n    description: 需要分割的文件路径\\\\n  - name: divide_sign\\\\n    type: string\\\\n    required: false\\\\n    description: 文本分隔符，支持普通字符串或自定义模式\\\\n    default: \\\\\\\"\\\\\\\\n\\\\\\\\n\\\\\\\"\\\\noutputs:\\\\n  - name: context\\\\n    type: string\\\\n    description: 分割后的文本内容片段\\\\n  - name: num\\\\n    type: integer\\\\n    description: 当前文本片段的序号\\\\n  - name: Is_Last\\\\n    type: boolean\\\\n    description: 是否为最后一个文本片段\\\\n  - name: Total_Num\\\\n    type: integer\\\\n    description: 文本片段总数\\\\n```\\\\n\\\\n- 文件读取阶段：尝试使用多种编码格式（utf-8、gb2312、gbk、gb18030、ascii）自动识别并读取指定文件内容\\\\n- 分隔符解析：检查输入的分隔符是否为自定义模式（格式：字符1@<X>字符2），如果是则解析为正则表达式模式\\\\n- 文本分割处理：根据分隔符类型选择相应的分割方法，自定义模式使用正则表达式分割并保留分隔符，普通模式直接按字符串分割\\\\n- 内容过滤：移除分割后的空白片段，确保输出内容的有效性\\\\n- 输出构建：为每个有效的文本片段创建包含四个输出字段的对象，包括片段内容、序号、是否最后一个的标识和总片段数\\\\n- 数组生成：使用深度复制确保每个输出对象的独立性，返回完整的片段数组供后续节点逐一处理"
    },
    {
        "Filename": "txttrriger_new.py",
        "Hash": "75670078832fcf08f2c6691c7a2ef52c9d1969ff038b94da5a1eeb3b68d3ca80",
        "NodeKind": "ArrayTrigger",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个多格式文件分割处理器，能够读取并分割不同类型的文件内容（支持txt、pdf、ppt格式），将大型文档按指定规则分割成小片段进行处理。\\n\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n核心算法包括：文件类型自动识别、多编码格式兼容读取、灵活的分割规则解析（支持自定义分隔符、页面分割、正则表达式模式）、内容分组处理、以及结构化输出生成。主要处理步骤为文件读取→内容分割→分组处理→结果输出。\\n\\n参数\\\\n```yaml\\\\ninputs:\\\\n  - name: file_path\\\\n    type: file\\\\n    required: true\\\\n    description: 待分割的文件路径，支持txt、pdf、ppt格式\\\\n  - name: divide_sign\\\\n    type: string\\\\n    required: false\\\\n    description: 分割符号，支持普通字符串、\\\"Page\\\"模式或\\\"字符1@<X>字符2\\\"自定义格式\\\\n    default: \\\"\\\\\\\\n\\\\\\\\n\\\"\\\\n  - name: Max_ArrayNum\\\\n    type: string\\\\n    required: false\\\\n    description: 每组包含的片段数量，用于将分割结果进行分组\\\\n    default: \\\"1\\\"\\\\noutputs:\\\\n  - name: context\\\\n    type: string\\\\n    description: 分割后的文本内容片段\\\\n  - name: num\\\\n    type: integer\\\\n    description: 当前片段在结果数组中的序号\\\\n  - name: Is_Last\\\\n    type: boolean\\\\n    description: 标识当前片段是否为最后一个片段\\\\n  - name: Total_Num\\\\n    type: integer\\\\n    description: 分割后的总片段数量\\\\n```\\n\\n运行逻辑（用 - 列表描写详细流程）\\\\n- 读取输入参数：文件路径、分割符号和分组大小\\\\n- 根据文件扩展名识别文件类型（.txt/.pdf/.ppt/.pptx）\\\\n- 针对不同文件类型采用相应的读取方式：PDF使用PdfReader逐页提取文本，PPT使用Presentation读取幻灯片内容，文本文件尝试多种编码格式读取\\\\n- 解析分割规则：若divide_sign为\\\"Page\\\"则按页面分割，若包含\\\"@<>\\\"格式则解析为自定义正则表达式模式，否则使用普通字符串分割\\\\n- 根据分割规则对文件内容进行分割：自定义模式使用正则表达式分割并保留分隔符，其他情况使用字符串split方法\\\\n- 过滤空白内容，移除只包含空格或换行的片段\\\\n- 根据Max_ArrayNum参数对分割结果进行分组，将多个片段合并为一个输出单元\\\\n- 为每个分割片段生成完整的输出信息：包含内容、序号、是否最后一个、总数量等属性\\\\n- 返回包含所有分割结果的结构化数组，每个元素包含四个输出字段的完整信息"
    },
    {
        "Filename": "VideoAddBgm.py",
        "Hash": "d87246681dbf111de79f33bbd9d29d9b3682785eb0edc77b1d4a017651a96f31",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个视频音频合并处理组件，用于将外部音频文件与视频文件进行合并，支持音频循环播放、音量调节、插入时间控制等功能。\\\\n\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n使用 MoviePy 库加载视频和音频文件，对音频进行音量调节和时间裁剪处理，根据需要循环音频以匹配视频时长，将处理后的音频与视频原有音轨进行混合，最终输出合并后的视频文件。\\\\n\\\\n参数\\\\n```yaml\\\\ninputs:\\\\n  - name: Video_Path\\\\n    type: file\\\\n    required: true\\\\n    description: 输入视频文件的路径\\\\n  - name: Mp3_Path\\\\n    type: file\\\\n    required: true\\\\n    description: 要合并的音频文件路径\\\\n  - name: SaveName\\\\n    type: string\\\\n    required: true\\\\n    description: 输出视频文件的名称\\\\n  - name: Is_Loop\\\\n    type: boolean\\\\n    required: true\\\\n    description: 是否循环播放音频以匹配视频时长\\\\n  - name: Mp3_Volumn\\\\n    type: string\\\\n    required: true\\\\n    description: 音频音量大小（浮点数字符串）\\\\n  - name: StartTime\\\\n    type: string\\\\n    required: true\\\\n    description: 音频开始插入的时间点（HH:MM:SS格式）\\\\n  - name: SavePath\\\\n    type: file\\\\n    required: true\\\\n    description: 输出文件保存目录路径\\\\noutputs:\\\\n  - name: Result\\\\n    type: string\\\\n    description: 处理结果状态信息\\\\n  - name: File_Path\\\\n    type: string\\\\n    description: 合并后视频文件的完整路径\\\\n```\\\\n\\\\n运行逻辑\\\\n- 获取并验证输入的视频文件路径和音频文件路径是否存在\\\\n- 解析音量参数为浮点数，如果解析失败则使用默认值0.3\\\\n- 解析开始时间字符串为秒数，格式必须为HH:MM:SS\\\\n- 使用MoviePy加载视频文件和音频文件\\\\n- 对音频应用音量调节效果\\\\n- 计算从开始时间到视频结束需要的音频时长\\\\n- 根据Is_Loop参数决定是否循环音频以匹配所需时长\\\\n- 如果循环，对音频应用淡入淡出效果以平滑过渡\\\\n- 如果不循环，裁剪音频到所需时长\\\\n- 设置音频的开始时间点\\\\n- 将处理后的音频与视频原有音轨进行混合\\\\n- 构建输出文件路径，如果未指定保存路径则使用默认临时目录\\\\n- 使用libx264视频编码器和aac音频编码器保存合并后的视频\\\\n- 清理资源并返回处理结果和输出文件路径"
    },
    {
        "Filename": "VideoConnect.py",
        "Hash": "5de91d098b1667dbed035c5d1327cf211ddcd2681ae850a24b2c524bf4363ea5",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个视频处理和合并节点，用于将多个分散在不同数字文件夹中的视频文件按顺序合并成一个完整的视频文件，并在合并过程中对每个视频进行1.1倍速处理。\\\\n\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n该节点通过自然数字排序算法定位并收集指定目录结构下的视频文件，使用MoviePy库对每个视频进行速度调整，然后将所有处理后的视频片段按顺序合并为单一视频文件，最终输出到指定路径。\\\\n\\\\n参数\\\\n```yaml\\\\ninputs:\\\\n  - name: Base_Path\\\\n    type: string\\\\n    required: true\\\\n    description: 基础文件路径，用于指定待处理视频文件所在的根目录\\\\n  - name: SaveName\\\\n    type: string\\\\n    required: true\\\\n    description: 保存的文件名，不需要扩展名，最终合并的视频将自动添加.mp4扩展名\\\\noutputs:\\\\n  - name: Result\\\\n    type: string\\\\n    description: 输出处理结果的详细信息字符串，包含处理过程中的每个步骤信息和最终视频的输出路径\\\\n```\\\\n\\\\n运行逻辑（用 - 列表描写详细流程）\\\\n- 验证输入的基础路径是否存在，如果路径无效则抛出异常\\\\n- 扫描基础路径下的所有子文件夹，筛选出以纯数字命名的文件夹\\\\n- 使用自然数字排序算法对数字文件夹进行排序，确保按正确的数字顺序处理\\\\n- 在每个数字文件夹的\\\"完整音频\\\"子目录中查找\\\"Srt+Video.mp4\\\"文件\\\\n- 收集所有找到的有效视频文件路径，如果未找到任何视频文件则抛出异常\\\\n- 逐个加载视频文件，创建VideoFileClip对象（包含音频轨道）\\\\n- 对每个视频剪辑应用1.1倍速效果，同时保持音频同步\\\\n- 将所有处理后的视频剪辑添加到剪辑列表中\\\\n- 使用concatenate_videoclips方法将所有视频剪辑按顺序合并成一个完整视频\\\\n- 构建输出文件路径，使用指定的SaveName加上.mp4扩展名\\\\n- 将合并后的视频写入文件，使用libx264视频编码器和aac音频编码器\\\\n- 清理所有视频剪辑资源，关闭文件句柄以释放内存\\\\n- 返回包含详细处理过程日志和最终输出路径的结果字符串\\\\n- 如果处理过程中出现任何异常，记录错误信息并返回失败状态"
    },
    {
        "Filename": "voiceadd.py",
        "Hash": "51c9caaad8993e5809a96011eb0e27a773a5c9e005b168da6f84d7483e35600b",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能：这是一个音频合成与字幕生成的处理节点，能够将多个音频文件按顺序合并成一个MP3文件，同时生成对应的SRT字幕文件，支持在现有音频基础上追加新内容。\\\\n\\\\n代码功能摘要：通过MoviePy库实现音频文件的读取、拼接和导出，在音频片段间插入静音间隙，同时根据音频时长和对应文本内容生成标准SRT格式字幕文件，支持批量处理和追加模式。\\\\n\\\\n参数：\\\\n```yaml\\\\ninputs:\\\\n  - name: save_path\\\\n    type: string\\\\n    required: true\\\\n    description: 保存生成文件的目标文件夹路径\\\\n  - name: save_name\\\\n    type: string\\\\n    required: true\\\\n    description: 生成的音频和字幕文件的基础名称（不含扩展名）\\\\n  - name: use_voice\\\\n    type: string\\\\n    required: true\\\\n    description: 音频文件路径，支持单个文件路径或文件路径列表\\\\n  - name: use_txt\\\\n    type: string\\\\n    required: true\\\\n    description: 对应的文本文件路径，与音频文件一一对应，用于生成字幕内容\\\\noutputs:\\\\n  - name: result\\\\n    type: string\\\\n    description: 返回处理结果信息，包含生成的音频和字幕文件路径\\\\n```\\\\n\\\\n运行逻辑：\\\\n- 获取输入参数并检查音频和文本文件列表格式，如果是单个字符串则转换为列表\\\\n- 构建输出文件路径，包括MP3音频文件和SRT字幕文件的完整路径\\\\n- 检查目标音频文件是否已存在，如果存在则加载作为基础音频，获取其时长作为起始时间\\\\n- 遍历输入的音频文件列表，依次处理每个音频文件\\\\n- 对每个音频文件执行加载操作，获取音频时长信息\\\\n- 读取对应的文本文件内容，如果文件不存在则使用\\\"无文本\\\"作为默认内容\\\\n- 根据当前时间位置和音频时长计算字幕的开始和结束时间戳\\\\n- 将音频片段和对应的字幕条目添加到处理列表中\\\\n- 在每个音频片段之间插入0.3秒的静音间隙\\\\n- 使用concatenate_audioclips函数将所有音频片段（包括原有音频、新音频和静音间隙）合并\\\\n- 将合并后的音频导出为MP3格式文件\\\\n- 将生成的字幕条目按SRT标准格式写入字幕文件，使用追加模式保留原有内容\\\\n- 返回包含生成文件路径信息的结果字符串"
    },
    {
        "Filename": "VoicetoVideo.py",
        "Hash": "a1f79ea0a18240b6cad18fbc31ce29d790944e43e4259ce7a5e78d55fef02123",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能：这是一个音频文件合并与字幕生成的组件，能够将多个音频文件按数字顺序合并，并根据对应的文本文件生成同步的字幕文件。\\\\n\\\\n代码功能摘要：使用moviepy库处理音频合并，通过文件名中的数字进行排序，根据音频时长计算字幕时间戳，最终输出合并的MP3音频文件和SRT/TXT格式的字幕文件。\\\\n\\\\n参数：\\\\n```yaml\\\\ninputs:\\\\n  - name: save_path\\\\n    type: file\\\\n    required: true\\\\n    description: 输出文件保存路径\\\\n  - name: save_name\\\\n    type: string\\\\n    required: true\\\\n    description: 输出文件名称（不含扩展名）\\\\n  - name: Voice_Path\\\\n    type: file\\\\n    required: true\\\\n    description: 音频文件夹路径，支持mp3和wav格式\\\\n  - name: Txt_path\\\\n    type: file\\\\n    required: true\\\\n    description: 字幕文本文件夹路径\\\\noutputs:\\\\n  - name: result\\\\n    type: string\\\\n    description: 操作执行结果的描述信息\\\\n  - name: File_Path\\\\n    type: string\\\\n    description: 合并后音频文件的完整路径\\\\n```\\\\n\\\\n运行逻辑：\\\\n- 从指定的音频目录读取所有mp3和wav格式的音频文件\\\\n- 从指定的文本目录读取所有txt格式的字幕文件\\\\n- 通过正则表达式提取文件名中的数字，对音频文件和文本文件进行排序\\\\n- 使用moviepy库逐个加载音频文件，创建音频剪辑对象\\\\n- 读取对应的txt文件内容作为字幕文本\\\\n- 根据音频时长计算每段字幕的开始和结束时间戳\\\\n- 生成SRT格式的字幕条目，包含时间范围和文本内容\\\\n- 使用concatenate_audioclips函数将所有音频剪辑合并为一个完整的音频\\\\n- 将合并后的音频导出为MP3格式文件\\\\n- 将字幕条目写入SRT格式文件和TXT格式文件\\\\n- 返回操作结果描述和输出音频文件的完整路径"
    },
    {
        "Filename": "WeChatTrigger.py",
        "Hash": "3818e3e0c5cd6ed07bd5f7ef2f81460d6fb6383fd138e23b51ffeb54b83a8afd",
        "NodeKind": "passivityTrigger",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个监听信息的被动触发节点，用于从本地5111端口获取未回复的消息，并将消息发送者和内容传递给后续节点进行处理。\\\\n\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n通过HTTP GET请求获取消息列表，遍历查找第一条未回答的消息（Isanswered=False），将消息的发送者昵称和内容分别输出，支持异常处理机制。\\\\n\\\\n参数\\\\n```yaml\\\\ninputs: []\\\\noutputs:\\\\n  - name: OutPut1\\\\n    type: string\\\\n    description: 发送消息的用户昵称\\\\n  - name: OutPut2\\\\n    type: string\\\\n    description: 发送的消息内容\\\\n```\\\\n\\\\n运行逻辑\\\\n- 初始化输出数组，将所有输出的Context设置为None\\\\n- 向本地127.0.0.1:5111/messages端点发送GET请求获取消息列表\\\\n- 解析响应的JSON数据获取消息数组\\\\n- 遍历消息列表，查找第一条Isanswered字段为False的未回复消息\\\\n- 找到未回复消息后，将消息的nickname赋值给第一个输出，将content赋值给第二个输出\\\\n- 将输出数组添加到结果数组中，设置接收标志为True并跳出循环\\\\n- 如果发生网络请求异常或JSON解析错误，打印错误信息并返回None\\\\n- 如果成功获取到未回复消息，返回包含输出数据的数组；否则不返回任何值"
    },
    {
        "Filename": "wenxin-4.py",
        "Hash": "d3392afc18bb51969cdbd6d6f8884a978c729d5a50a2bcba192ebe24d21457a1",
        "NodeKind": "LLm",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个基于Claude Sonnet模型的大语言模型节点，通过HTTPS API调用实现智能对话和文本生成功能。支持系统提示词配置、温度等参数调节，并可选择原始文本或JSON格式输出。\\\\n\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n核心功能包括构建对话消息体、发送HTTPS请求到ChatAnywhere API、接收并解析模型响应。支持JSON格式智能解析，能够自动提取JSON内容并分配到多个输出节点，同时记录token使用统计信息。\\\\n\\\\n参数\\\\n```yaml\\\\ninputs: []\\\\noutputs:\\\\n  - name: OutPut1\\\\n    type: string\\\\n    description: 模型生成的回答内容或解析后的JSON数据\\\\n```\\\\n\\\\n运行逻辑\\\\n- 根据节点配置构造系统提示词，结合SystemPrompt和ExprotAfterPrompt\\\\n- 创建包含system和user角色的消息数组，system角色承载提示词，user角色承载具体问题\\\\n- 建立SSL安全连接到api.chatanywhere.tech，配置请求头包含API密钥和内容类型\\\\n- 构建请求载荷，包含模型名称、温度、最大token数、top_p等参数\\\\n- 发送POST请求到/v1/chat/completions端点，获取模型响应\\\\n- 解析返回的JSON数据，提取模型生成的文本内容\\\\n- 根据OriginalTextSelector设置判断输出格式：原始文本直接输出，JSON格式则进行深度解析\\\\n- JSON解析包括去除代码块标记、查找平衡括号区域、转义换行符、清理控制字符等步骤\\\\n- 将解析后的JSON键值对分配到对应的输出节点，支持动态扩展输出节点数量\\\\n- 记录prompt_tokens、completion_tokens、total_tokens等使用统计信息到输出节点"
    },
    {
        "Filename": "wenxin-4cc.py",
        "Hash": "cc19b259c804d4e8b44934316c6c9834147261ef6a881925df52a2f6dd424b20",
        "NodeKind": "LLm",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\n这是一个基于Claude Sonnet模型的大语言模型节点，通过HTTPS API调用实现智能对话和文本生成功能。支持系统提示词配置、温度等参数调节，并可选择原始文本或JSON格式输出。\\\\n\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\n核心功能包括构建对话消息体、发送HTTPS请求到ChatAnywhere API、接收并解析模型响应。支持JSON格式智能解析，能够自动提取JSON内容并分配到多个输出节点，同时记录token使用统计信息。\\\\n\\\\n参数\\\\n```yaml\\\\ninputs: []\\\\noutputs:\\\\n  - name: OutPut1\\\\n    type: string\\\\n    description: 模型生成的回答内容或解析后的JSON数据\\\\n```\\\\n\\\\n运行逻辑\\\\n- 根据节点配置构造系统提示词，结合SystemPrompt和ExprotAfterPrompt\\\\n- 创建包含system和user角色的消息数组，system角色承载提示词，user角色承载具体问题\\\\n- 建立SSL安全连接到api.chatanywhere.tech，配置请求头包含API密钥和内容类型\\\\n- 构建请求载荷，包含模型名称、温度、最大token数、top_p等参数\\\\n- 发送POST请求到/v1/chat/completions端点，获取模型响应\\\\n- 解析返回的JSON数据，提取模型生成的文本内容\\\\n- 根据OriginalTextSelector设置判断输出格式：原始文本直接输出，JSON格式则进行深度解析\\\\n- JSON解析包括去除代码块标记、查找平衡括号区域、转义换行符、清理控制字符等步骤\\\\n- 将解析后的JSON键值对分配到对应的输出节点，支持动态扩展输出节点数量\\\\n- 记录prompt_tokens、completion_tokens、total_tokens等使用统计信息到输出节点"
    },
    {
        "Filename": "WordsNum2soccer.py",
        "Hash": "a5baa563c87b3ac51523d84c694a83c5130a05d257499fff463d3c30a43b6c2c",
        "NodeKind": "Normal",
        "NodeFunction": "组件功能（简述代码整体功能）\\\\\\\\n\\\\\\\\n根据输入的字数计算对应的分数，实现字数与分数的映射转换。\\\\\\\\n\\\\\\\\n代码功能摘要（概括核心算法或主要处理步骤）\\\\\\\\n\\\\\\\\n采用分段计分规则：字数大于等于930分得10分，530-929字数区间按每50字为一个计分单位递减，少于530字得2分。通过整数转换和条件判断实现字数到分数的精确映射。\\\\\\\\n\\\\\\\\n参数\\\\\\\\n\\\\\\\\n```yaml\\\\\\\\ninputs:\\\\\\\\n  - name: Input1\\\\\\\\n    type: string\\\\\\\\n    required: true\\\\\\\\n    description: 需要计算分数的字数\\\\\\\\noutputs:\\\\\\\\n  - name: OutPut1\\\\\\\\n    type: string\\\\\\\\n    description: 根据字数计算得出的分数\\\\\\\\n```\\\\\\\\n\\\\\\\\n运行逻辑\\\\\\\\n\\\\\\\\n- 接收输入的字数参数并尝试转换为整数类型\\\\\\\\n- 判断字数是否大于等于930，如果是则直接赋予10分\\\\\\\\n- 判断字数是否在530-929区间内，如果是则计算缺少的50字块数量\\\\\\\\n- 根据缺少的块数从10分中扣除相应分数得到最终得分\\\\\\\\n- 如果字数少于530则直接赋予2分\\\\\\\\n- 处理输入格式错误的情况，返回错误提示信息\\\\\\\\n- 将计算结果存储到输出节点并返回"
    },
    {
        "Filename": "WordToExcel.py",
        "Hash": "7592adc2c395bf3c139acffcb9e39a9f973da57bd841965fd7af04b97c3d98b0",
        "NodeKind": "ArrayTrigger",
        "NodeFunction": "这是一个文本分割处理组件，专门用于将包含多个问答对的文本文件按\\\"答案\\\"关键词进行分割处理。\\\\n\\\\n组件功能：读取指定的文本文件，自动检测文件编码，使用正则表达式按\\\"答案\\\"关键词将文本分割成多个独立的问答对片段，并为每个片段提供详细的处理状态信息。\\\\n\\\\n代码功能摘要：程序首先使用chardet库检测文件编码确保正确读取，然后通过正则表达式re.split()按\\\"答案\\\"关键词分割文本内容，将问题和对应答案重新组合成完整的问答对，最后为每个片段生成包含内容、序号和结束标记的输出对象数组。\\\\n\\\\n参数：\\\\n```yaml\\\\ninputs:\\\\n  - name: Input1\\\\n    type: file\\\\n    required: true\\\\n    description: 要处理的文本文件路径\\\\noutputs:\\\\n  - name: context\\\\n    type: string\\\\n    description: 分割后的问答对文本内容\\\\n  - name: num\\\\n    type: integer\\\\n    description: 当前处理片段的序号\\\\n  - name: Is_Last\\\\n    type: boolean\\\\n    description: 标记是否为最后一个片段\\\\n```\\\\n\\\\n运行逻辑：\\\\n- 读取输入的文件路径参数\\\\n- 使用chardet库读取文件前1000字节检测文件编码格式\\\\n- 根据检测到的编码格式完整读取文件内容\\\\n- 使用正则表达式re.split()按\\\"答案\\\"关键词分割文本内容\\\\n- 将分割后的内容重新组合，确保每个片段包含完整的问题和对应答案\\\\n- 遍历所有分割后的片段，为每个片段创建输出对象\\\\n- 将片段内容存储到context输出，记录序号到num输出\\\\n- 判断是否为最后一个片段并设置Is_Last标记\\\\n- 使用深拷贝将每个输出对象添加到结果数组中\\\\n- 返回包含所有处理结果的数组供后续节点使用"
    }
]